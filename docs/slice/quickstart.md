# Quickstart: Your First Slice

Create and deploy a slice in 5 minutes.

## Prerequisites

- Java 25+
- Maven 3.8+
- JBCT CLI 0.6.0+ installed (`jbct --version` should work)

## Step 1: Create Project

```bash
jbct init --slice greeting-service
cd greeting-service
```

This creates a complete slice project with:
- `@Slice` interface with nested records and factory method
- Nested implementation record
- Request/Response/ValidationError records (all nested)
- Slice config (`src/main/resources/slices/GreetingService.toml`)
- Unit test
- Deploy scripts

## Step 2: Explore the Generated Code

**GreetingService.java** - The complete slice (single file):
```java
@Slice
public interface GreetingService {
    /**
     * Request record.
     */
    record Request(String value) {
        public static Result<Request> request(String value) {
            if (value == null || value.isBlank()) {
                return Result.failure(ValidationError.emptyValue());
            }
            return Result.success(new Request(value));
        }
    }

    /**
     * Response record.
     */
    record Response(String result) {}

    /**
     * Validation error.
     */
    sealed interface ValidationError extends Cause {
        record EmptyValue() implements ValidationError {
            @Override
            public String message() {
                return "Value cannot be empty";
            }
        }

        static ValidationError emptyValue() {
            return new EmptyValue();
        }
    }

    Promise<Response> process(Request request);

    static GreetingService greetingService() {
        record greetingService() implements GreetingService {
            @Override
            public Promise<Response> process(Request request) {
                var response = new Response("Processed: " + request.value());
                return Promise.success(response);
            }
        }
        return new greetingService();
    }
}
```

## Step 3: Build and Test

```bash
mvn verify
```

This:
1. Compiles the source
2. Runs annotation processing (generates factory, manifest)
3. Runs tests
4. Packages into slice JAR

Check the generated files:
```bash
ls target/classes/META-INF/slice/
# GreetingService.manifest

ls target/classes/org/example/greetingservice/
# GreetingServiceFactory.class (generated)
```

## Step 4: Generate Blueprint

```bash
./generate-blueprint.sh
```

Output:
```toml
# Generated by jbct:generate-blueprint
id = "org.example:greeting-service:1.0.0-SNAPSHOT"

[[slices]]
artifact = "org.example:greeting-service:1.0.0-SNAPSHOT"
instances = 1
```

## Step 5: Deploy to Local Forge

Start a local Aether Forge (if not running), then:

```bash
./deploy-forge.sh
```

Your slice is now running and accessible at `http://localhost:8080`.

## What Just Happened?

1. **Annotation processor** read your `@Slice` interface and generated:
   - `GreetingServiceFactory.java` - factory that wires dependencies
   - `META-INF/slice/GreetingService.manifest` - metadata for packaging

2. **Maven plugin** packaged a single **slice JAR** containing:
   - `greeting-service.jar` - interface + implementation + factory + types

3. **Blueprint generator** created `blueprint.toml` with your slice listed (properties from `src/main/resources/slices/GreetingService.toml`)

4. **Deploy script** ran `mvn install` to install JAR to your local Maven repository (`~/.m2/repository`)

5. **Aether Forge** detected the new slice and loaded it automatically

## Next Steps

- [Add a dependency](development-guide.md#adding-dependencies) to another slice
- [Create multiple slices](development-guide.md#multiple-slices) in one module
- [Configure deployment](deployment.md) for test/prod environments
- [Understand the internals](architecture.md) of how slices work
