# Slice Factory Generation Design

## Overview

This document describes the automatic generation of slice factory methods following JBCT conventions. The goal is to eliminate boilerplate while maintaining type safety and predictability.

## Design Decisions

### D1: Factory Return Type

**Decision**: Factory methods return `Promise<SliceType>`, never `Result<Promise<...>>` or `Promise<Result<...>>`.

**Rationale**: Promise is the asynchronous version of Result by design. Wrapping one in the other is redundant and violates JBCT principles.

```java
// CORRECT
static Promise<MySlice> mySlice(Aspect aspect, UserRepository repo) { ... }

// WRONG - never wrap Result in Promise or vice versa
static Promise<Result<MySlice>> mySlice(...) { ... }
```

### D2: Aspect Parameter

**Decision**: First parameter is always `Aspect aspect` (not `Option<Aspect>`). Identity aspect is used when no decoration is needed.

**Rationale**:
- Eliminates conditional logic in factory
- Single vtable indirect call (Java is optimized for this)
- Identity aspect costs nothing at runtime
- Simpler, more predictable code

```java
static Promise<MySlice> mySlice(Aspect aspect, ...) {
    var instance = createInstance(...);
    return Promise.successful(aspect.apply(instance));
}
```

### D3: Adapter Dependency Discovery

**Decision**: Adapter dependencies are identified by being **external to the slice's base package**. They are exclusively other slices (external or infrastructure).

**Discovery Algorithm**:
1. Start from `@Slice` interface
2. Find factory method (follows `TypeName.typeName(...)` naming)
3. Trace implementation dependencies
4. Filter to dependencies outside base package
5. These are adapter leaf dependencies

**Package Rule**:
- Same base package = internal implementation detail
- Different base package = external dependency = adapter leaf

### D4: Maven Artifact Mapping

**Decision**: External dependencies map to Maven artifacts via the `slice-deps.properties` file generated by `jbct:collect-slice-deps`.

**Format**:
```properties
# Generated by jbct:collect-slice-deps
org.example:inventory-service:api=1.0.0
org.example:pricing-service:api=1.2.0
```

**Resolution**: When generating factory, class imports are matched against known artifacts to determine version.

### D5: Generated Factory Structure

**Decision**: Generate complete factory body following JBCT coding rules. Internal structure is implementation detail.

**Generated Pattern**:
```java
public final class MySliceFactory {
    private MySliceFactory() {}

    public static Promise<MySlice> create(Aspect aspect,
                                          SliceInvokerFacade invoker) {
        // Create proxies for all adapter dependencies
        var inventoryService = new InventoryServiceProxy(invoker,
            "org.example:inventory-service:1.0.0");
        var pricingService = new PricingServiceProxy(invoker,
            "org.example:pricing-service:1.2.0");

        // Create instance via original factory
        var instance = MySlice.mySlice(inventoryService, pricingService);

        // Apply aspect and return
        return Promise.successful(aspect.apply(instance));
    }
}
```

### D6: No Impl Classes

**Decision**: Following JBCT conventions, implementations are lambdas or local records, not separate `XxxImpl` classes.

**Rationale**:
- Factory methods encapsulate construction
- Implementation details stay internal
- Cleaner public API

## Dependency Discovery Algorithm

### Phase 1: Interface Analysis

```
Input: @Slice annotated interface
Output: SliceModel with methods, factory method, base package

1. Extract package name → base package
2. Find static factory method (lowercase-first naming convention)
3. Extract factory method parameters → initial dependency list
4. Extract interface methods → public API
```

### Phase 2: Dependency Classification

```
Input: Factory method parameters
Output: Classified dependencies (internal vs external)

For each parameter type:
1. Resolve full qualified name
2. Compare package to base package
3. If different package → external dependency (adapter leaf)
4. If same package → internal (skip, already assembled)
```

### Phase 3: Artifact Resolution

```
Input: External dependency types
Output: Maven artifact coordinates

For each external dependency:
1. Find in slice-deps.properties by class name
2. Extract groupId:artifactId:version
3. Store for proxy generation
```

### Phase 4: Factory Generation

```
Input: SliceModel + resolved dependencies
Output: Generated factory class

1. Generate factory class with private constructor
2. Generate create() method:
   a. First param: Aspect aspect
   b. Second param: SliceInvokerFacade invoker
   c. Create proxy for each external dependency
   d. Call original factory method
   e. Apply aspect
   f. Return Promise
```

## File Structure

```
slice-processor/
├── src/main/java/org/pragmatica/jbct/slice/
│   ├── SliceProcessor.java           # Annotation processor entry point
│   ├── model/
│   │   ├── SliceModel.java           # Slice metadata
│   │   ├── MethodModel.java          # Method info
│   │   └── DependencyModel.java      # Dependency info with classification
│   ├── analyzer/
│   │   └── DependencyAnalyzer.java   # NEW: Traces dependencies to adapters
│   └── generator/
│       ├── ApiInterfaceGenerator.java
│       ├── ProxyClassGenerator.java
│       ├── FactoryClassGenerator.java # UPDATED: New factory pattern
│       ├── ManifestGenerator.java
│       └── DependencyVersionResolver.java
└── docs/
    └── SLICE-FACTORY-GENERATION.md   # This document
```

## Example

### Input: Slice Interface

```java
package org.example.order;

@Slice
public interface PlaceOrder {
    Promise<OrderResult> placeOrder(PlaceOrderRequest request);

    // Factory method - parameters are external slice dependencies
    static PlaceOrder placeOrder(InventoryService inventory,
                                  PricingService pricing) {
        return new PlaceOrderImpl(inventory, pricing);
    }
}
```

### Analysis Result

```
Base package: org.example.order
Factory method: placeOrder(InventoryService, PricingService)
External dependencies:
  - org.example.inventory.api.InventoryService → org.example:inventory-service:1.0.0
  - org.example.pricing.api.PricingService → org.example:pricing-service:1.2.0
```

### Generated Factory

```java
package org.example.order;

import org.pragmatica.aether.slice.Aspect;
import org.pragmatica.aether.slice.SliceInvokerFacade;
import org.pragmatica.lang.Promise;
import org.example.inventory.api.InventoryService;
import org.example.inventory.api.InventoryServiceProxy;
import org.example.pricing.api.PricingService;
import org.example.pricing.api.PricingServiceProxy;

public final class PlaceOrderFactory {
    private PlaceOrderFactory() {}

    public static Promise<PlaceOrder> create(Aspect aspect,
                                              SliceInvokerFacade invoker) {
        var inventory = new InventoryServiceProxy(invoker,
            "org.example:inventory-service:1.0.0");
        var pricing = new PricingServiceProxy(invoker,
            "org.example:pricing-service:1.2.0");

        var instance = PlaceOrder.placeOrder(inventory, pricing);
        return Promise.successful(aspect.apply(instance));
    }

    public static final class Dependencies {
        public static final String INVENTORY_SERVICE = "org.example:inventory-service:1.0.0";
        public static final String PRICING_SERVICE = "org.example:pricing-service:1.2.0";
        private Dependencies() {}
    }
}
```

## Open Questions

1. **Aspect type**: What is the exact type signature of `Aspect`? Is it `Fn1<T, T>` or a dedicated interface?

2. **Async creation**: If slice creation itself can fail (e.g., initialization error), should factory return `Promise<SliceType>` with potential failure?

3. **Infrastructure slices**: Is there a registry of known infrastructure slice types (caching, logging, etc.) for special handling?

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2026-01-10 | Claude | Initial design document |
