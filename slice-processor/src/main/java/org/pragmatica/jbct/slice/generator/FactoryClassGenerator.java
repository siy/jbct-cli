package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.MethodModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

/**
 * Generates factory class for slice instantiation.
 * <p>
 * Generated factory contains:
 * <ul>
 *   <li>{@code create(Aspect, SliceInvokerFacade)} - returns typed slice instance</li>
 *   <li>{@code createSlice(Aspect, SliceInvokerFacade)} - returns Slice for Aether runtime</li>
 * </ul>
 * <p>
 * External dependencies get local proxy records inside create() method.
 * Internal dependencies are instantiated via their factory methods.
 */
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try {
            var factoryName = model.simpleName() + "Factory";
            var qualifiedName = model.packageName() + "." + factoryName;

            JavaFileObject file = filer.createSourceFile(qualifiedName);
            try (var writer = new PrintWriter(file.openWriter())) {
                generateFactoryClass(writer, model, factoryName);
            }

            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getMessage())
                         .result();
        }
    }

    private void generateFactoryClass(PrintWriter out, SliceModel model, String factoryName) {
        var sliceName = model.simpleName();
        var basePackage = model.packageName();

        // Collect external dependencies
        var externalDeps = model.dependencies()
                                .stream()
                                .filter(dep -> dep.isExternal(basePackage))
                                .map(versionResolver::resolve)
                                .toList();

        var internalDeps = model.dependencies()
                                .stream()
                                .filter(dep -> !dep.isExternal(basePackage))
                                .toList();

        // Package
        out.println("package " + basePackage + ";");
        out.println();

        // Imports
        generateImports(out, model, externalDeps, internalDeps);
        out.println();

        // Class
        out.println("/**");
        out.println(" * Factory for " + sliceName + " slice.");
        out.println(" * Generated by slice-processor - do not edit manually.");
        out.println(" */");
        out.println("public final class " + factoryName + " {");
        out.println("    private " + factoryName + "() {}");
        out.println();

        // create() method
        generateCreateMethod(out, model, externalDeps, internalDeps);
        out.println();

        // createSlice() method
        generateCreateSliceMethod(out, model);

        out.println("}");
    }

    private void generateImports(PrintWriter out,
                                  SliceModel model,
                                  List<DependencyModel> externalDeps,
                                  List<DependencyModel> internalDeps) {
        out.println("import org.pragmatica.aether.slice.Aspect;");
        out.println("import org.pragmatica.aether.slice.MethodName;");
        out.println("import org.pragmatica.aether.slice.Slice;");
        out.println("import org.pragmatica.aether.slice.SliceInvokerFacade;");
        out.println("import org.pragmatica.aether.slice.SliceMethod;");
        out.println("import org.pragmatica.lang.Promise;");
        out.println("import org.pragmatica.lang.Unit;");
        out.println("import org.pragmatica.lang.type.TypeToken;");
        out.println();
        out.println("import java.util.List;");

        // Import external dependency interfaces
        for (var dep : externalDeps) {
            out.println("import " + dep.interfaceQualifiedName() + ";");
        }

        // Import internal dependency interfaces (those in subpackages)
        var basePackage = model.packageName();
        for (var dep : internalDeps) {
            if (!dep.interfacePackage().equals(basePackage)) {
                out.println("import " + dep.interfaceQualifiedName() + ";");
            }
        }
    }

    private void generateCreateMethod(PrintWriter out,
                                       SliceModel model,
                                       List<DependencyModel> externalDeps,
                                       List<DependencyModel> internalDeps) {
        var sliceName = model.simpleName();

        out.println("    public static Promise<" + sliceName + "> create(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");

        // Generate local proxy records for external dependencies
        for (var dep : externalDeps) {
            generateLocalProxyRecord(out, dep);
            out.println();
        }

        // Instantiate internal dependencies
        for (var dep : internalDeps) {
            out.println("        var " + dep.parameterName() + " = " +
                       dep.interfaceSimpleName() + "." + dep.factoryMethodName() + "();");
        }

        // Instantiate external dependencies (using local proxy records)
        for (var dep : externalDeps) {
            out.println("        var " + dep.parameterName() + " = new " +
                       dep.localRecordName() + "(invoker);");
        }

        out.println();

        // Call developer's factory
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("        var instance = " + sliceName + "." + model.factoryMethodName() +
                   "(" + String.join(", ", factoryArgs) + ");");
        out.println("        return Promise.success(aspect.apply(instance));");
        out.println("    }");
    }

    private void generateLocalProxyRecord(PrintWriter out, DependencyModel dep) {
        var recordName = dep.localRecordName();
        var interfaceName = dep.interfaceSimpleName();
        var artifact = dep.fullArtifact().or(() -> "UNRESOLVED");

        out.println("        record " + recordName + "(SliceInvokerFacade invoker) implements " + interfaceName + " {");
        out.println("            private static final String ARTIFACT = \"" + artifact + "\";");

        // Generate method implementations
        var interfaceElement = elements.getTypeElement(dep.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers().contains(Modifier.STATIC) &&
                        !method.getModifiers().contains(Modifier.DEFAULT)) {
                        generateProxyMethod(out, method);
                    }
                }
            }
        }

        out.println("        }");
    }

    private void generateProxyMethod(PrintWriter out, ExecutableElement method) {
        var methodName = method.getSimpleName().toString();
        var returnType = method.getReturnType();
        var params = method.getParameters();

        // Extract response type from Promise<T>
        var responseType = extractPromiseTypeArg(returnType);
        if (responseType == null) {
            return;
        }

        // Slice methods always have exactly one parameter
        if (params.size() != 1) {
            return;
        }

        var param = params.getFirst();
        var paramType = param.asType().toString();
        var paramName = param.getSimpleName().toString();

        out.println();
        out.println("            @Override");
        out.println("            public " + returnType + " " + methodName + "(" + paramType + " " + paramName + ") {");
        out.println("                return invoker.invoke(ARTIFACT, \"" + methodName + "\", " +
                   paramName + ", " + responseType + ".class);");
        out.println("            }");
    }

    private void generateCreateSliceMethod(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var sliceRecordName = Character.toLowerCase(sliceName.charAt(0)) + sliceName.substring(1) + "Slice";

        out.println("    public static Promise<Slice> createSlice(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");

        // Generate local adapter record
        out.println("        record " + sliceRecordName + "(" + sliceName + " delegate) implements Slice {");
        out.println("            @Override");
        out.println("            public List<SliceMethod<?, ?>> methods() {");
        out.println("                return List.of(");

        // Generate SliceMethod entries for each method
        var methods = model.methods();
        for (int i = 0; i < methods.size(); i++) {
            var method = methods.get(i);
            var comma = (i < methods.size() - 1) ? "," : "";
            out.println("                    new SliceMethod<>(");
            out.println("                        MethodName.methodName(\"" + method.name() + "\").unwrap(),");
            out.println("                        delegate::" + method.name() + ",");
            out.println("                        new TypeToken<" + method.responseType() + ">() {},");
            out.println("                        new TypeToken<" + method.parameterType() + ">() {}");
            out.println("                    )" + comma);
        }

        out.println("                );");
        out.println("            }");
        out.println("        }");
        out.println();
        out.println("        return create(aspect, invoker)");
        out.println("                   .map(" + sliceRecordName + "::new);");
        out.println("    }");
    }

    private String extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return typeArgs.getFirst().toString();
            }
        }
        return null;
    }
}
