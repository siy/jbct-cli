package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

/**
 * Generates factory class for slice instantiation.
 * <p>
 * Generated factory contains:
 * <ul>
 *   <li>{@code create(Aspect, SliceInvokerFacade)} - returns typed slice instance</li>
 *   <li>{@code createSlice(Aspect, SliceInvokerFacade)} - returns Slice for Aether runtime</li>
 * </ul>
 * <p>
 * External dependencies get local proxy records inside create() method.
 * Internal dependencies are instantiated via their factory methods.
 */
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try {
            var factoryName = model.simpleName() + "Factory";
            var qualifiedName = model.packageName() + "." + factoryName;

            JavaFileObject file = filer.createSourceFile(qualifiedName);
            try (var writer = new PrintWriter(file.openWriter())) {
                generateFactoryClass(writer, model, factoryName);
            }

            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getMessage())
                         .result();
        }
    }

    private void generateFactoryClass(PrintWriter out, SliceModel model, String factoryName) {
        var sliceName = model.simpleName();
        var basePackage = model.packageName();

        // Collect external dependencies
        var externalDeps = model.dependencies()
                                .stream()
                                .filter(dep -> dep.isExternal(basePackage))
                                .map(versionResolver::resolve)
                                .toList();

        var internalDeps = model.dependencies()
                                .stream()
                                .filter(dep -> !dep.isExternal(basePackage))
                                .toList();

        // Package
        out.println("package " + basePackage + ";");
        out.println();

        // Imports
        generateImports(out, model, externalDeps, internalDeps);
        out.println();

        // Class
        out.println("/**");
        out.println(" * Factory for " + sliceName + " slice.");
        out.println(" * Generated by slice-processor - do not edit manually.");
        out.println(" */");
        out.println("public final class " + factoryName + " {");
        out.println("    private " + factoryName + "() {}");
        out.println();

        // create() method
        generateCreateMethod(out, model, externalDeps, internalDeps);
        out.println();

        // createSlice() method
        generateCreateSliceMethod(out, model);

        out.println("}");
    }

    private void generateImports(PrintWriter out,
                                  SliceModel model,
                                  List<DependencyModel> externalDeps,
                                  List<DependencyModel> internalDeps) {
        out.println("import org.pragmatica.aether.slice.Aspect;");
        out.println("import org.pragmatica.aether.slice.MethodHandle;");
        out.println("import org.pragmatica.aether.slice.MethodName;");
        out.println("import org.pragmatica.aether.slice.Slice;");
        out.println("import org.pragmatica.aether.slice.SliceInvokerFacade;");
        out.println("import org.pragmatica.aether.slice.SliceMethod;");
        out.println("import org.pragmatica.lang.Promise;");
        out.println("import org.pragmatica.lang.Unit;");
        out.println("import org.pragmatica.lang.type.TypeToken;");
        out.println();
        out.println("import java.util.List;");

        // Import external dependency interfaces
        for (var dep : externalDeps) {
            out.println("import " + dep.interfaceQualifiedName() + ";");
        }

        // Import internal dependency interfaces (those in subpackages)
        var basePackage = model.packageName();
        for (var dep : internalDeps) {
            if (!dep.interfacePackage().equals(basePackage)) {
                out.println("import " + dep.interfaceQualifiedName() + ";");
            }
        }
    }

    private void generateCreateMethod(PrintWriter out,
                                       SliceModel model,
                                       List<DependencyModel> externalDeps,
                                       List<DependencyModel> internalDeps) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);

        out.println("    public static Promise<" + sliceName + "> " + methodName + "(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");

        // Generate local proxy records for external dependencies
        for (var dep : externalDeps) {
            generateLocalProxyRecord(out, dep);
            out.println();
        }

        // Create method handles for external dependencies (eager, fail-fast)
        for (var dep : externalDeps) {
            generateHandleCreation(out, dep);
            out.println();
        }

        // Instantiate internal dependencies
        for (var dep : internalDeps) {
            out.println("        var " + dep.parameterName() + " = " +
                       dep.interfaceSimpleName() + "." + dep.factoryMethodName() + "();");
        }

        // Instantiate external dependencies with pre-created handles
        for (var dep : externalDeps) {
            generateProxyInstantiation(out, dep);
        }

        out.println();

        // Call developer's factory
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("        var instance = " + sliceName + "." + model.factoryMethodName() +
                   "(" + String.join(", ", factoryArgs) + ");");
        out.println("        return Promise.success(aspect.apply(instance));");
        out.println("    }");
    }

    private record ProxyMethodInfo(String name, String responseType, String paramType) {}

    private List<ProxyMethodInfo> collectProxyMethods(DependencyModel dep) {
        var methods = new ArrayList<ProxyMethodInfo>();
        var interfaceElement = elements.getTypeElement(dep.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers().contains(Modifier.STATIC) &&
                        !method.getModifiers().contains(Modifier.DEFAULT) &&
                        method.getParameters().size() == 1) {
                        var responseType = extractPromiseTypeArg(method.getReturnType());
                        if (responseType != null) {
                            var paramType = method.getParameters().getFirst().asType().toString();
                            methods.add(new ProxyMethodInfo(method.getSimpleName().toString(), responseType, paramType));
                        }
                    }
                }
            }
        }
        return methods;
    }

    private void generateLocalProxyRecord(PrintWriter out, DependencyModel dep) {
        var recordName = dep.localRecordName();
        var interfaceName = dep.interfaceSimpleName();
        var methods = collectProxyMethods(dep);

        // Generate record with MethodHandle components
        var components = methods.stream()
                                .map(m -> "MethodHandle<" + m.responseType + ", " + m.paramType + "> " + m.name + "Handle")
                                .toList();
        out.println("        record " + recordName + "(" + String.join(", ", components) + ") implements " + interfaceName + " {");

        // Generate method implementations
        for (var method : methods) {
            generateProxyMethod(out, method);
        }

        out.println("        }");
    }

    private void generateProxyMethod(PrintWriter out, ProxyMethodInfo method) {
        out.println();
        out.println("            @Override");
        out.println("            public Promise<" + method.responseType + "> " + method.name + "(" + method.paramType + " request) {");
        out.println("                return " + method.name + "Handle.invoke(request);");
        out.println("            }");
    }

    private void generateHandleCreation(PrintWriter out, DependencyModel dep) {
        var artifact = dep.fullArtifact().or(() -> "UNRESOLVED");
        var methods = collectProxyMethods(dep);

        for (var method : methods) {
            var handleVar = dep.parameterName() + "_" + method.name;
            out.println("        var " + handleVar + " = invoker.methodHandle(\"" + artifact + "\", \"" + method.name + "\",");
            out.println("                                                     new TypeToken<" + method.paramType + ">() {},");
            out.println("                                                     new TypeToken<" + method.responseType + ">() {});");
            out.println("        if (" + handleVar + ".isFailure()) {");
            out.println("            return Promise.failure(" + handleVar + ".cause());");
            out.println("        }");
        }
    }

    private void generateProxyInstantiation(PrintWriter out, DependencyModel dep) {
        var methods = collectProxyMethods(dep);
        var handleArgs = methods.stream()
                                .map(m -> dep.parameterName() + "_" + m.name + ".value()")
                                .toList();
        out.println("        var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ", handleArgs) + ");");
    }

    private void generateCreateSliceMethod(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        var sliceRecordName = methodName + "Slice";

        out.println("    public static Promise<Slice> " + methodName + "Slice(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");

        // Generate local adapter record
        out.println("        record " + sliceRecordName + "(" + sliceName + " delegate) implements Slice {");
        out.println("            @Override");
        out.println("            public List<SliceMethod<?, ?>> methods() {");
        out.println("                return List.of(");

        // Generate SliceMethod entries for each method
        var methods = model.methods();
        for (int i = 0; i < methods.size(); i++) {
            var method = methods.get(i);
            var comma = (i < methods.size() - 1) ? "," : "";
            out.println("                    new SliceMethod<>(");
            out.println("                        MethodName.methodName(\"" + method.name() + "\").unwrap(),");
            out.println("                        delegate::" + method.name() + ",");
            out.println("                        new TypeToken<" + method.responseType() + ">() {},");
            out.println("                        new TypeToken<" + method.parameterType() + ">() {}");
            out.println("                    )" + comma);
        }

        out.println("                );");
        out.println("            }");
        out.println("        }");
        out.println();
        out.println("        return " + methodName + "(aspect, invoker)");
        out.println("                   .map(" + sliceRecordName + "::new);");
        out.println("    }");
    }

    private String extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return typeArgs.getFirst().toString();
            }
        }
        return null;
    }

    private String lowercaseFirst(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }
        return Character.toLowerCase(name.charAt(0)) + name.substring(1);
    }
}
