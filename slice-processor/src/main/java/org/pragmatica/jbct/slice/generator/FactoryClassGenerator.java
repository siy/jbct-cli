package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Generates factory class for slice instantiation.
 * <p>
 * Generated factory follows JBCT conventions:
 * <ul>
 *   <li>First parameter: Aspect to apply to created instance</li>
 *   <li>Second parameter: SliceInvokerFacade for remote calls</li>
 *   <li>Returns Promise&lt;SliceType&gt; (never Result wrapped in Promise)</li>
 *   <li>Always applies aspect (use identity aspect for no decoration)</li>
 * </ul>
 */
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    private static final ClassName SLICE_INVOKER_FACADE = ClassName.get("org.pragmatica.aether.slice",
                                                                        "SliceInvokerFacade");
    private static final ClassName ASPECT = ClassName.get("org.pragmatica.aether.slice",
                                                          "Aspect");
    private static final ClassName PROMISE = ClassName.get("org.pragmatica.lang",
                                                           "Promise");

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try{
            var factoryName = model.simpleName() + "Factory";
            var sliceType = ClassName.get(model.packageName(), model.simpleName());
            var promiseOfSlice = ParameterizedTypeName.get(PROMISE, sliceType);
            var aspectOfSlice = ParameterizedTypeName.get(ASPECT, sliceType);
            var classBuilder = TypeSpec.classBuilder(factoryName)
                                       .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                                       .addJavadoc("Factory for $L slice.\n",
                                                   model.simpleName())
                                       .addJavadoc("Creates proxy instances, applies aspect, and returns Promise.\n")
                                       .addJavadoc("Generated by slice-processor - do not edit manually.\n");
            // Private constructor
            classBuilder.addMethod(MethodSpec.constructorBuilder()
                                             .addModifiers(Modifier.PRIVATE)
                                             .build());
            // Create method
            var createMethod = MethodSpec.methodBuilder("create")
                                         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                                         .returns(promiseOfSlice)
                                         .addParameter(aspectOfSlice, "aspect")
                                         .addParameter(SLICE_INVOKER_FACADE, "invoker")
                                         .addJavadoc("Create $L slice with all dependencies.\n\n",
                                                     model.simpleName())
                                         .addJavadoc("@param aspect Aspect to apply (use Aspect.identity() for none)\n")
                                         .addJavadoc("@param invoker The slice invoker for remote calls\n")
                                         .addJavadoc("@return Promise of configured $L instance\n",
                                                     model.simpleName());
            // Create proxy for each dependency
            var factoryArgs = new StringBuilder();
            for (var dep : model.dependencies()) {
                var resolved = versionResolver.resolve(dep);
                var proxyType = ClassName.get(model.apiPackage(), resolved.proxyClassName());
                var varName = resolved.parameterName();
                createMethod.addStatement("var $L = new $T(invoker, $S)",
                                          varName,
                                          proxyType,
                                          resolved.fullArtifact());
                if (!factoryArgs.isEmpty()) {
                    factoryArgs.append(", ");
                }
                factoryArgs.append(varName);
            }
            // Call original factory, apply aspect, wrap in Promise
            createMethod.addStatement("var instance = $T.$L($L)",
                                      sliceType,
                                      model.factoryMethodName(),
                                      factoryArgs.toString());
            createMethod.addStatement("return $T.successful(aspect.apply(instance))",
                                      PROMISE);
            classBuilder.addMethod(createMethod.build());
            // Dependencies inner class
            var depsBuilder = TypeSpec.classBuilder("Dependencies")
                                      .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                      .addJavadoc("Dependency information for this slice.\n");
            depsBuilder.addMethod(MethodSpec.constructorBuilder()
                                            .addModifiers(Modifier.PRIVATE)
                                            .build());
            for (var dep : model.dependencies()) {
                var resolved = versionResolver.resolve(dep);
                var constName = toConstantName(resolved.parameterName());
                depsBuilder.addField(FieldSpec.builder(String.class, constName)
                                              .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                              .initializer("$S",
                                                           resolved.fullArtifact())
                                              .build());
            }
            classBuilder.addType(depsBuilder.build());
            var javaFile = JavaFile.builder(model.packageName(),
                                            classBuilder.build())
                                   .indent("    ")
                                   .build();
            javaFile.writeTo(filer);
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getMessage())
                         .result();
        }
    }

    private String toConstantName(String name) {
        // camelCase -> SCREAMING_SNAKE_CASE
        var result = new StringBuilder();
        for (int i = 0; i < name.length(); i++) {
            char c = name.charAt(i);
            if (Character.isUpperCase(c) && i > 0) {
                result.append('_');
            }
            result.append(Character.toUpperCase(c));
        }
        return result.toString();
    }
}
