package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Generates factory class for slice instantiation.
 * <p>
 * Generated factory follows JBCT conventions:
 * <ul>
 *   <li>First parameter: Aspect to apply to created instance</li>
 *   <li>Second parameter: SliceInvokerFacade for remote calls</li>
 *   <li>Returns Promise&lt;SliceType&gt; (never Result wrapped in Promise)</li>
 *   <li>Always applies aspect (use identity aspect for no decoration)</li>
 * </ul>
 * <p>
 * Two factory methods are generated:
 * <ul>
 *   <li>{@code create(Aspect, SliceInvokerFacade)} - static aspect configuration</li>
 *   <li>{@code createDynamic(DynamicAspectConfig, SliceInvokerFacade)} - runtime-configurable aspects</li>
 * </ul>
 */
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    private static final ClassName SLICE_INVOKER_FACADE = ClassName.get("org.pragmatica.aether.slice",
                                                                        "SliceInvokerFacade");
    private static final ClassName ASPECT = ClassName.get("org.pragmatica.aether.slice",
                                                          "Aspect");
    private static final ClassName DYNAMIC_ASPECT_CONFIG = ClassName.get("org.pragmatica.aether.slice",
                                                                          "DynamicAspectConfig");
    private static final ClassName PROMISE = ClassName.get("org.pragmatica.lang",
                                                           "Promise");

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try{
            var factoryName = model.simpleName() + "Factory";
            var sliceType = ClassName.get(model.packageName(), model.simpleName());
            var promiseOfSlice = ParameterizedTypeName.get(PROMISE, sliceType);
            var aspectOfSlice = ParameterizedTypeName.get(ASPECT, sliceType);
            var classBuilder = TypeSpec.classBuilder(factoryName)
                                       .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                                       .addJavadoc("Factory for $L slice.\n",
                                                   model.simpleName())
                                       .addJavadoc("Creates proxy instances, applies aspect, and returns Promise.\n")
                                       .addJavadoc("Generated by slice-processor - do not edit manually.\n");
            // Private constructor
            classBuilder.addMethod(MethodSpec.constructorBuilder()
                                             .addModifiers(Modifier.PRIVATE)
                                             .build());
            // Create method (static aspect)
            classBuilder.addMethod(buildCreateMethod(model, sliceType, promiseOfSlice, aspectOfSlice));
            // CreateDynamic method (runtime-configurable aspects)
            classBuilder.addMethod(buildCreateDynamicMethod(model, sliceType, promiseOfSlice));
            // Dependencies inner class
            classBuilder.addType(buildDependenciesClass(model));
            var javaFile = JavaFile.builder(model.packageName(),
                                            classBuilder.build())
                                   .indent("    ")
                                   .build();
            javaFile.writeTo(filer);
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getMessage())
                         .result();
        }
    }

    private MethodSpec buildCreateMethod(SliceModel model,
                                         ClassName sliceType,
                                         ParameterizedTypeName promiseOfSlice,
                                         ParameterizedTypeName aspectOfSlice) {
        var createMethod = MethodSpec.methodBuilder("create")
                                     .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                                     .returns(promiseOfSlice)
                                     .addParameter(aspectOfSlice, "aspect")
                                     .addParameter(SLICE_INVOKER_FACADE, "invoker")
                                     .addJavadoc("Create $L slice with static aspect.\n\n",
                                                 model.simpleName())
                                     .addJavadoc("@param aspect Aspect to apply (use Aspect.identity() for none)\n")
                                     .addJavadoc("@param invoker The slice invoker for remote calls\n")
                                     .addJavadoc("@return Promise of configured $L instance\n",
                                                 model.simpleName());
        // Create proxy for each dependency
        var factoryArgs = new StringBuilder();
        for (var dep : model.dependencies()) {
            var resolved = versionResolver.resolve(dep);
            var proxyType = ClassName.get(model.apiPackage(), resolved.proxyClassName());
            var varName = resolved.parameterName();
            createMethod.addStatement("var $L = new $T(invoker, $S)",
                                      varName,
                                      proxyType,
                                      resolved.fullArtifact());
            if (!factoryArgs.isEmpty()) {
                factoryArgs.append(", ");
            }
            factoryArgs.append(varName);
        }
        // Call original factory, apply aspect, wrap in Promise
        createMethod.addStatement("var instance = $T.$L($L)",
                                  sliceType,
                                  model.factoryMethodName(),
                                  factoryArgs.toString());
        createMethod.addStatement("return $T.successful(aspect.apply(instance))",
                                  PROMISE);
        return createMethod.build();
    }

    private MethodSpec buildCreateDynamicMethod(SliceModel model,
                                                ClassName sliceType,
                                                ParameterizedTypeName promiseOfSlice) {
        var createDynamic = MethodSpec.methodBuilder("createDynamic")
                                      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                                      .returns(promiseOfSlice)
                                      .addParameter(DYNAMIC_ASPECT_CONFIG, "config")
                                      .addParameter(SLICE_INVOKER_FACADE, "invoker")
                                      .addJavadoc("Create $L slice with dynamic runtime-configurable aspects.\n",
                                                  model.simpleName())
                                      .addJavadoc("Enables runtime toggling of logging/metrics without restart.\n\n")
                                      .addJavadoc("@param config Dynamic aspect configuration (runtime-updatable)\n")
                                      .addJavadoc("@param invoker The slice invoker for remote calls\n")
                                      .addJavadoc("@return Promise of configured $L instance\n",
                                                  model.simpleName());
        // Create proxy for each dependency wrapped with dynamic aspect
        var factoryArgs = new StringBuilder();
        for (var dep : model.dependencies()) {
            var resolved = versionResolver.resolve(dep);
            var proxyType = ClassName.get(model.apiPackage(), resolved.proxyClassName());
            var depType = ClassName.get(dep.interfacePackage(), dep.interfaceSimpleName());
            var varName = resolved.parameterName();
            // config.aspectFor(DepType.class).apply(new DepProxy(invoker, artifact))
            createDynamic.addStatement("var $L = config.aspectFor($T.class).apply(new $T(invoker, $S))",
                                       varName,
                                       depType,
                                       proxyType,
                                       resolved.fullArtifact());
            if (!factoryArgs.isEmpty()) {
                factoryArgs.append(", ");
            }
            factoryArgs.append(varName);
        }
        // Create instance
        createDynamic.addStatement("var instance = $T.$L($L)",
                                   sliceType,
                                   model.factoryMethodName(),
                                   factoryArgs.toString());
        // Apply slice-level dynamic aspect and return
        createDynamic.addStatement("return $T.successful(config.aspectFor($T.class).apply(instance))",
                                   PROMISE,
                                   sliceType);
        return createDynamic.build();
    }

    private TypeSpec buildDependenciesClass(SliceModel model) {
        var depsBuilder = TypeSpec.classBuilder("Dependencies")
                                  .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                  .addJavadoc("Dependency information for this slice.\n");
        depsBuilder.addMethod(MethodSpec.constructorBuilder()
                                        .addModifiers(Modifier.PRIVATE)
                                        .build());
        for (var dep : model.dependencies()) {
            var resolved = versionResolver.resolve(dep);
            var constName = toConstantName(resolved.parameterName());
            depsBuilder.addField(FieldSpec.builder(String.class, constName)
                                          .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                                          .initializer("$S",
                                                       resolved.fullArtifact())
                                          .build());
        }
        return depsBuilder.build();
    }

    private String toConstantName(String name) {
        // camelCase -> SCREAMING_SNAKE_CASE
        var result = new StringBuilder();
        for (int i = 0; i < name.length(); i++) {
            char c = name.charAt(i);
            if (Character.isUpperCase(c) && i > 0) {
                result.append('_');
            }
            result.append(Character.toUpperCase(c));
        }
        return result.toString();
    }
}
