package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.KeyExtractorInfo;
import org.pragmatica.jbct.slice.model.MethodModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Generates factory class for slice instantiation.
 * <p>
 * Generated factory contains:
 * <ul>
 *   <li>{@code create(Aspect, SliceInvokerFacade)} - returns typed slice instance</li>
 *   <li>{@code createSlice(Aspect, SliceInvokerFacade)} - returns Slice for Aether runtime</li>
 * </ul>
 * <p>
 * All dependencies get local proxy records that delegate to SliceInvokerFacade.
 * <p>
 * When methods have @Aspect annotations, generates wrapper record with
 * aspect-wrapped method implementations.
 * <p>
 * Currently supported aspects:
 * <ul>
 *   <li>{@code CACHE} - Fully implemented with key extraction</li>
 *   <li>{@code LOG} - Planned, not yet implemented</li>
 *   <li>{@code METRICS} - Planned, not yet implemented</li>
 *   <li>{@code RETRY} - Planned, not yet implemented</li>
 *   <li>{@code TIMEOUT} - Planned, not yet implemented</li>
 * </ul>
 */
public class FactoryClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;
    private final DependencyVersionResolver versionResolver;

    public FactoryClassGenerator(Filer filer,
                                 Elements elements,
                                 Types types,
                                 DependencyVersionResolver versionResolver) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
        this.versionResolver = versionResolver;
    }

    public Result<Unit> generate(SliceModel model) {
        try{
            var factoryName = model.simpleName() + "Factory";
            var qualifiedName = model.packageName() + "." + factoryName;
            JavaFileObject file = filer.createSourceFile(qualifiedName);
            try (var writer = new PrintWriter(file.openWriter())) {
                generateFactoryClass(writer, model, factoryName);
            }
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate factory class: " + e.getClass()
                                                                        .getSimpleName() + ": " + e.getMessage())
                         .result();
        }
    }

    private void generateFactoryClass(PrintWriter out, SliceModel model, String factoryName) {
        var sliceName = model.simpleName();
        var basePackage = model.packageName();
        // Resolve all dependencies - all go through invoker
        var allDeps = model.dependencies()
                           .stream()
                           .map(versionResolver::resolve)
                           .toList();
        // Cache proxy methods per dependency to avoid repeated lookups
        var proxyMethodsCache = new HashMap<String, List<ProxyMethodInfo>>();
        for (var dep : allDeps) {
            proxyMethodsCache.put(dep.interfaceQualifiedName(), collectProxyMethods(dep));
        }
        // Package
        out.println("package " + basePackage + ";");
        out.println();
        // Imports
        generateImports(out, model, allDeps);
        out.println();
        // Class
        out.println("/**");
        out.println(" * Factory for " + sliceName + " slice.");
        out.println(" * Generated by slice-processor - do not edit manually.");
        out.println(" */");
        out.println("public final class " + factoryName + " {");
        out.println("    private " + factoryName + "() {}");
        out.println();
        // create() method
        generateCreateMethod(out, model, allDeps, proxyMethodsCache);
        out.println();
        // createSlice() method
        generateCreateSliceMethod(out, model);
        out.println("}");
    }

    private void generateImports(PrintWriter out,
                                 SliceModel model,
                                 List<DependencyModel> allDeps) {
        out.println("import org.pragmatica.aether.slice.Aspect;");
        out.println("import org.pragmatica.aether.slice.MethodHandle;");
        out.println("import org.pragmatica.aether.slice.MethodName;");
        out.println("import org.pragmatica.aether.slice.Slice;");
        out.println("import org.pragmatica.aether.slice.SliceInvokerFacade;");
        out.println("import org.pragmatica.aether.slice.SliceMethod;");
        out.println("import org.pragmatica.lang.Promise;");
        out.println("import org.pragmatica.lang.Unit;");
        out.println("import org.pragmatica.lang.type.TypeToken;");
        // Aspect-related imports
        if (model.hasAspects()) {
            out.println("import org.pragmatica.aether.slice.SliceRuntime;");
            out.println("import org.pragmatica.aether.infra.aspect.Aspects;");
            out.println("import org.pragmatica.lang.Functions.Fn1;");
        }
        if (model.hasCache()) {
            out.println("import org.pragmatica.aether.infra.aspect.Cache;");
            out.println("import org.pragmatica.aether.infra.aspect.CacheConfig;");
        }
        out.println();
        out.println("import java.util.List;");
        // Import all dependency interfaces
        var basePackage = model.packageName();
        for (var dep : allDeps) {
            if (!dep.interfacePackage()
                    .equals(basePackage)) {
                out.println("import " + dep.interfaceQualifiedName() + ";");
            }
        }
    }

    private void generateCreateMethod(PrintWriter out,
                                      SliceModel model,
                                      List<DependencyModel> allDeps,
                                      Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        // Split dependencies
        var infraDeps = allDeps.stream()
                               .filter(DependencyModel::isInfrastructure)
                               .toList();
        var sliceDeps = allDeps.stream()
                               .filter(d -> !d.isInfrastructure())
                               .toList();
        out.println("    public static Promise<" + sliceName + "> " + methodName + "(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");
        // Generate local proxy records ONLY for slice dependencies
        for (var dep : sliceDeps) {
            generateLocalProxyRecord(out, dep, proxyMethodsCache);
            out.println();
        }
        // Generate wrapper record if aspects are present
        if (model.hasAspects()) {
            generateWrapperRecord(out, model);
            out.println();
        }
        // Build the creation chain
        if (model.hasAspects()) {
            generateAspectCreateChain(out, model, infraDeps, sliceDeps, proxyMethodsCache);
        } else if (infraDeps.isEmpty() && sliceDeps.isEmpty()) {
            // No dependencies at all
            var factoryArgs = model.dependencies()
                                   .stream()
                                   .map(DependencyModel::parameterName)
                                   .toList();
            out.println("        var instance = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                    factoryArgs)
                        + ");");
            out.println("        return Promise.success(aspect.apply(instance));");
        } else {
            generateMixedDependencyChain(out, model, infraDeps, sliceDeps, proxyMethodsCache);
        }
        out.println("    }");
    }

    private void generateWrapperRecord(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var wrapperName = sliceName + "Wrapper";
        // Generate record components - one Fn1 per method
        var components = new ArrayList<String>();
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            components.add("Fn1<Promise<" + responseType + ">, " + paramType + "> " + method.name() + "Fn");
        }
        out.println("        record " + wrapperName + "(" + String.join(",\n                                  ",
                                                                        components) + ")");
        out.println("               implements " + sliceName + " {");
        // Generate method implementations
        for (var method : model.methods()) {
            var responseType = method.responseType()
                                     .toString();
            var paramType = method.parameterType()
                                  .toString();
            out.println();
            out.println("            @Override");
            out.println("            public Promise<" + responseType + "> " + method.name() + "(" + paramType
                        + " request) {");
            out.println("                return " + method.name() + "Fn.apply(request);");
            out.println("            }");
        }
        out.println("        }");
    }

    private void generateAspectCreateChain(PrintWriter out,
                                           SliceModel model,
                                           List<DependencyModel> infraDeps,
                                           List<DependencyModel> sliceDeps,
                                           Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        var wrapperName = sliceName + "Wrapper";
        // Collect all cache methods for cache creation
        var cacheMethods = model.methods()
                                .stream()
                                .filter(m -> m.aspects()
                                              .hasCache())
                                .toList();
        // Start with SliceRuntime.getAspectFactory()
        out.println("        return SliceRuntime.getAspectFactory()");
        out.println("                           .async()");
        // Generate cache creation flatMaps
        var cacheVarNames = new ArrayList<String>();
        for (int i = 0; i < cacheMethods.size(); i++) {
            var method = cacheMethods.get(i);
            var cacheVarName = method.name() + "Cache";
            cacheVarNames.add(cacheVarName);
            var keyExtractor = getKeyExtractorOrThrow(method);
            var keyType = keyExtractor.keyType();
            var responseType = method.responseType()
                                     .toString();
            var cacheName = escapeJavaString(lowercaseFirst(sliceName) + "." + method.name());
            out.println("                           .flatMap(factory -> CacheConfig.cacheConfig(\"" + cacheName + "\",");
            out.println("                                                                       new TypeToken<" + keyType
                        + ">() {},");
            out.println("                                                                       new TypeToken<" + responseType
                        + ">() {})");
            out.println("                                                          .async()");
            out.println("                                                          .flatMap(cfg -> factory.create(Cache.class, cfg).async()))");
        }
        // Handle infra dependencies first
        if (!infraDeps.isEmpty()) {
            for (var infra : infraDeps) {
                out.println("                           .flatMap(" + (cacheVarNames.isEmpty()
                                                                      ? "factory"
                                                                      : cacheVarNames.getLast()) + " -> " + generateInfraStoreCall(infra)
                            + ")");
            }
        }
        // Handle slice dependencies
        if (!sliceDeps.isEmpty()) {
            var allHandles = new ArrayList<HandleInfo>();
            for (var dep : sliceDeps) {
                var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
                for (var proxyMethod : methods) {
                    allHandles.add(new HandleInfo(dep, proxyMethod));
                }
            }
            var prevVar = infraDeps.isEmpty()
                          ? (cacheVarNames.isEmpty()
                             ? "factory"
                             : cacheVarNames.getLast())
                          : infraDeps.getLast()
                                     .parameterName();
            for (var handle : allHandles) {
                out.println("                           .flatMap(" + prevVar + " -> " + generateMethodHandleCall(handle)
                            + ")");
                prevVar = handle.varName();
            }
        }
        // Final map to create wrapper
        var lastVar = determineLastVariableName(infraDeps, sliceDeps, cacheVarNames, proxyMethodsCache);
        out.println("                           .map(" + lastVar + " -> {");
        // Instantiate slice dependency proxies only
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> dep.parameterName() + "_" + m.name)
                                    .toList();
            out.println("                               var " + dep.parameterName() + " = new " + dep.localRecordName()
                        + "(" + String.join(", ", handleArgs) + ");");
        }
        // Create the impl instance
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println("                               var impl = " + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                                   factoryArgs)
                    + ");");
        out.println();
        // Create wrapped functions for each method
        int cacheIdx = 0;
        for (var method : model.methods()) {
            var wrappedVar = method.name() + "Wrapped";
            if (method.aspects()
                      .hasCache()) {
                var keyExtractor = getKeyExtractorOrThrow(method);
                var cacheVar = cacheVarNames.get(cacheIdx++);
                out.println("                               var " + wrappedVar + " = Aspects.withCaching(impl::" + method.name()
                            + ", " + keyExtractor.extractorExpression() + ", " + cacheVar + ");");
            } else {
                out.println("                               Fn1<Promise<" + method.responseType() + ">, " + method.parameterType()
                            + "> " + wrappedVar + " = impl::" + method.name() + ";");
            }
        }
        out.println();
        // Return wrapped instance
        var wrappedArgs = model.methods()
                               .stream()
                               .map(m -> m.name() + "Wrapped")
                               .toList();
        out.println("                               return aspect.apply(new " + wrapperName + "(" + String.join(", ",
                                                                                                                wrappedArgs)
                    + "));");
        out.println("                           });");
    }

    /**
     * Gets the key extractor from method aspects, throwing if missing.
     * This should never happen if MethodModel.extractAspects() works correctly.
     */
    private KeyExtractorInfo getKeyExtractorOrThrow(MethodModel method) {
        return method.aspects()
                     .keyExtractor()
                     .or(() -> {
                             // This is a logic error - CACHE aspect should always have key extractor
        throw new IllegalStateException("CACHE aspect on method '" + method.name()
                                        + "' is missing key extractor. This indicates a bug in MethodModel.extractAspects().");
                         });
    }

    private void generateFlatMapChain(PrintWriter out,
                                      SliceModel model,
                                      List<DependencyModel> allDeps,
                                      Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        // Collect all handles across all dependencies
        var allHandles = new ArrayList<HandleInfo>();
        for (var dep : allDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            for (var method : methods) {
                allHandles.add(new HandleInfo(dep, method));
            }
        }
        // Start the chain
        out.println("        return " + generateMethodHandleCall(allHandles.getFirst()));
        // Generate nested flatMaps
        var indent = "            ";
        for (int i = 1; i < allHandles.size(); i++) {
            var handle = allHandles.get(i);
            var prevHandle = allHandles.get(i - 1);
            out.println(indent + ".flatMap(" + prevHandle.varName() + " -> " + generateMethodHandleCall(handle));
            indent += "    ";
        }
        // Final map with proxy instantiation and factory call
        var lastHandle = allHandles.getLast();
        out.println(indent + ".map(" + lastHandle.varName() + " -> {");
        // Instantiate proxies
        for (var dep : allDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> new HandleInfo(dep, m).varName())
                                    .toList();
            out.println(indent + "    var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ",
                                                                                                                          handleArgs)
                        + ");");
        }
        // Call developer's factory
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println(indent + "    return aspect.apply(" + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                          factoryArgs)
                    + "));");
        // Close all flatMaps and the final map
        if (allHandles.size() == 1) {
            // Single handle: just close .map with semicolon
            out.println(indent + "});");
        } else {
            // Multiple handles: close .map, then close all flatMaps
            out.println(indent + "})");
            for (int i = 1; i < allHandles.size(); i++) {
                indent = indent.substring(4);
                if (i == allHandles.size() - 1) {
                    out.println(indent + ");");
                } else {
                    out.println(indent + ")");
                }
            }
        }
    }

    private record HandleInfo(DependencyModel dep, ProxyMethodInfo method) {
        String varName() {
            return dep.parameterName() + "_" + method.name;
        }
    }

    private String generateMethodHandleCall(HandleInfo handle) {
        var artifact = escapeJavaString(handle.dep.fullArtifact()
                                              .or(() -> "UNRESOLVED"));
        var methodName = escapeJavaString(handle.method.name);
        return "invoker.methodHandle(\"" + artifact + "\", \"" + methodName + "\",\n"
               + "                                                     new TypeToken<" + handle.method.paramType
               + ">() {},\n" + "                                                     new TypeToken<" + handle.method.responseType
               + ">() {}).async()";
    }

    private record ProxyMethodInfo(String name, String responseType, String paramType) {}

    private List<ProxyMethodInfo> collectProxyMethods(DependencyModel dep) {
        var methods = new ArrayList<ProxyMethodInfo>();
        var interfaceElement = elements.getTypeElement(dep.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers()
                               .contains(Modifier.STATIC) &&
                    !method.getModifiers()
                           .contains(Modifier.DEFAULT) &&
                    method.getParameters()
                          .size() == 1) {
                        extractPromiseTypeArg(method.getReturnType())
                        .onPresent(responseType -> {
                                       var paramType = method.getParameters()
                                                             .getFirst()
                                                             .asType()
                                                             .toString();
                                       methods.add(new ProxyMethodInfo(method.getSimpleName()
                                                                             .toString(),
                                                                       responseType,
                                                                       paramType));
                                   });
                    }
                }
            }
        }
        return methods;
    }

    private void generateLocalProxyRecord(PrintWriter out,
                                          DependencyModel dep,
                                          Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var recordName = dep.localRecordName();
        var interfaceName = dep.interfaceSimpleName();
        var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
        // Generate record with MethodHandle components
        var components = methods.stream()
                                .map(m -> "MethodHandle<" + m.responseType + ", " + m.paramType + "> " + m.name
                                          + "Handle")
                                .toList();
        out.println("        record " + recordName + "(" + String.join(", ", components) + ") implements " + interfaceName
                    + " {");
        // Generate method implementations
        for (var method : methods) {
            generateProxyMethod(out, method);
        }
        out.println("        }");
    }

    private void generateProxyMethod(PrintWriter out, ProxyMethodInfo method) {
        out.println();
        out.println("            @Override");
        out.println("            public Promise<" + method.responseType + "> " + method.name + "(" + method.paramType
                    + " request) {");
        out.println("                return " + method.name + "Handle.invoke(request);");
        out.println("            }");
    }

    private void generateCreateSliceMethod(PrintWriter out, SliceModel model) {
        var sliceName = model.simpleName();
        var methodName = lowercaseFirst(sliceName);
        var sliceRecordName = methodName + "Slice";
        out.println("    public static Promise<Slice> " + methodName + "Slice(Aspect<" + sliceName + "> aspect,");
        out.println("                                              SliceInvokerFacade invoker) {");
        // Generate local adapter record
        out.println("        record " + sliceRecordName + "(" + sliceName + " delegate) implements Slice, " + sliceName + " {");
        out.println("            @Override");
        out.println("            public List<SliceMethod<?, ?>> methods() {");
        out.println("                return List.of(");
        // Generate SliceMethod entries for each method
        var methods = model.methods();
        for (int i = 0; i < methods.size(); i++) {
            var method = methods.get(i);
            var comma = (i < methods.size() - 1)
                        ? ","
                        : "";
            var escapedMethodName = escapeJavaString(method.name());
            out.println("                    new SliceMethod<>(");
            out.println("                        MethodName.methodName(\"" + escapedMethodName + "\").unwrap(),");
            out.println("                        delegate::" + method.name() + ",");
            out.println("                        new TypeToken<" + method.responseType() + ">() {},");
            out.println("                        new TypeToken<" + method.parameterType() + ">() {}");
            out.println("                    )" + comma);
        }
        out.println("                );");
        out.println("            }");
        // Generate delegate methods for the slice interface
        for (var method : methods) {
            out.println();
            out.println("            @Override");
            out.println("            public " + method.returnType() + " " + method.name() + "(" + method.parameterType() + " " + method.parameterName() + ") {");
            out.println("                return delegate." + method.name() + "(" + method.parameterName() + ");");
            out.println("            }");
        }
        out.println("        }");
        out.println();
        out.println("        return " + methodName + "(aspect, invoker)");
        out.println("                   .map(" + sliceRecordName + "::new);");
        out.println("    }");
    }

    private Option<String> extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return Option.some(typeArgs.getFirst()
                                           .toString());
            }
        }
        return Option.none();
    }

    /**
     * Escapes a string for safe embedding in Java string literals.
     * Handles quotes, backslashes, and common control characters.
     */
    private String escapeJavaString(String input) {
        if (input == null) {
            return "";
        }
        var sb = new StringBuilder(input.length());
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            switch (c) {
                case '"' -> sb.append("\\\"");
                case '\\' -> sb.append("\\\\");
                case '\n' -> sb.append("\\n");
                case '\r' -> sb.append("\\r");
                case '\t' -> sb.append("\\t");
                default -> sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Converts first letter to lowercase following JBCT naming conventions.
     * Handles acronyms properly: "HTTPService" -> "httpService", "IOReader" -> "ioReader"
     */
    private String lowercaseFirst(String name) {
        if (name == null || name.isEmpty()) {
            return "";
        }
        // Find the end of leading uppercase sequence
        int i = 0;
        while (i < name.length() && Character.isUpperCase(name.charAt(i))) {
            i++;
        }
        if (i == 0) {
            // Already lowercase
            return name;
        }
        if (i == 1) {
            // Single uppercase letter: "Service" -> "service"
            return Character.toLowerCase(name.charAt(0)) + name.substring(1);
        }
        // Acronym: "HTTPService" -> "httpService", "HTTP" -> "http"
        // Lowercase all but last uppercase if followed by lowercase
        if (i < name.length()) {
            // There's more after the acronym, keep last uppercase
            return name.substring(0, i - 1)
                       .toLowerCase() + name.substring(i - 1);
        }
        // Entire string is uppercase acronym: "HTTP" -> "http"
        return name.toLowerCase();
    }

    /**
     * Determines the variable name to use in the final .map() lambda.
     * Handles empty collections safely to avoid NoSuchElementException.
     */
    private String determineLastVariableName(List<DependencyModel> infraDeps,
                                             List<DependencyModel> sliceDeps,
                                             List<String> cacheVarNames,
                                             Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        // Try slice deps first
        if (!sliceDeps.isEmpty()) {
            var lastDep = sliceDeps.getLast();
            var methods = proxyMethodsCache.get(lastDep.interfaceQualifiedName());
            if (methods != null && !methods.isEmpty()) {
                return lastDep.parameterName() + "_" + methods.getLast().name;
            }
        }
        // Try infra deps
        if (!infraDeps.isEmpty()) {
            return infraDeps.getLast()
                            .parameterName();
        }
        // Fall back to cache var names
        if (!cacheVarNames.isEmpty()) {
            return cacheVarNames.getLast();
        }
        // Default to factory
        return "factory";
    }

    private void generateMixedDependencyChain(PrintWriter out,
                                              SliceModel model,
                                              List<DependencyModel> infraDeps,
                                              List<DependencyModel> sliceDeps,
                                              Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        var sliceName = model.simpleName();
        // Start with InfraStore chain
        if (!infraDeps.isEmpty()) {
            var firstInfra = infraDeps.getFirst();
            out.println("        return " + generateInfraStoreCall(firstInfra));
            // Chain remaining infra deps
            var indent = "            ";
            for (int i = 1; i < infraDeps.size(); i++) {
                var infra = infraDeps.get(i);
                var prevInfra = infraDeps.get(i - 1);
                out.println(indent + ".flatMap(" + prevInfra.parameterName() + " -> " + generateInfraStoreCall(infra)
                            + ")");
                indent += "    ";
            }
            // Chain slice dependency proxies if any
            if (!sliceDeps.isEmpty()) {
                var lastInfra = infraDeps.getLast();
                var allSliceHandles = new ArrayList<HandleInfo>();
                for (var dep : sliceDeps) {
                    var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
                    for (var method : methods) {
                        allSliceHandles.add(new HandleInfo(dep, method));
                    }
                }
                // First handle uses lastInfra as parameter
                var firstHandle = allSliceHandles.getFirst();
                out.println(indent + ".flatMap(" + lastInfra.parameterName() + " -> " + generateMethodHandleCall(firstHandle));
                indent += "    ";
                // Remaining handles use previous handle's varName
                for (int i = 1; i < allSliceHandles.size(); i++) {
                    var handle = allSliceHandles.get(i);
                    var prevHandle = allSliceHandles.get(i - 1);
                    out.println(indent + ".flatMap(" + prevHandle.varName() + " -> " + generateMethodHandleCall(handle));
                    indent += "    ";
                }
                // Final map with all dependencies
                var lastHandle = allSliceHandles.getLast();
                out.println(indent + ".map(" + lastHandle.varName() + " -> {");
                generateDependencyInstantiation(out, indent, sliceDeps, proxyMethodsCache);
                generateFactoryCall(out, indent, model);
                out.println(indent + "})");
                // Close all flatMaps
                for (int i = 0; i < infraDeps.size() - 1 + allSliceHandles.size(); i++) {
                    indent = indent.substring(4);
                    out.println(indent + ")");
                }
                out.println(indent.substring(4) + ";");
            } else {
                // Only infra deps, no slice deps
                var lastInfra = infraDeps.getLast();
                out.println(indent + ".map(" + lastInfra.parameterName() + " -> {");
                generateFactoryCall(out, indent, model);
                out.println(indent + "})");
                // Close all flatMaps
                for (int i = 0; i < infraDeps.size() - 1; i++) {
                    indent = indent.substring(4);
                    out.println(indent + ")");
                }
                out.println(indent.substring(4) + ";");
            }
        } else {
            // Only slice deps (existing flatMap logic)
            generateFlatMapChain(out, model, sliceDeps, proxyMethodsCache);
        }
    }

    private String generateInfraStoreCall(DependencyModel infra) {
        var interfaceName = infra.interfaceSimpleName();
        var factoryMethodName = toFactoryMethodName(interfaceName);
        return "Promise.success(" + interfaceName + "." + factoryMethodName + "())";
    }

    private String toFactoryMethodName(String className) {
        if (className == null || className.isEmpty()) {
            return className;
        }
        return Character.toLowerCase(className.charAt(0)) + className.substring(1);
    }

    private void generateDependencyInstantiation(PrintWriter out,
                                                 String indent,
                                                 List<DependencyModel> sliceDeps,
                                                 Map<String, List<ProxyMethodInfo>> proxyMethodsCache) {
        for (var dep : sliceDeps) {
            var methods = proxyMethodsCache.get(dep.interfaceQualifiedName());
            var handleArgs = methods.stream()
                                    .map(m -> dep.parameterName() + "_" + m.name)
                                    .toList();
            out.println(indent + "    var " + dep.parameterName() + " = new " + dep.localRecordName() + "(" + String.join(", ",
                                                                                                                          handleArgs)
                        + ");");
        }
    }

    private void generateFactoryCall(PrintWriter out, String indent, SliceModel model) {
        var sliceName = model.simpleName();
        var factoryArgs = model.dependencies()
                               .stream()
                               .map(DependencyModel::parameterName)
                               .toList();
        out.println(indent + "    return aspect.apply(" + sliceName + "." + model.factoryMethodName() + "(" + String.join(", ",
                                                                                                                          factoryArgs)
                    + "));");
    }
}
