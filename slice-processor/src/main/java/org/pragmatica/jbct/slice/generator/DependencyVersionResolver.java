package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.util.Properties;

/**
 * Resolves dependency artifact coordinates and versions from slice-deps.properties.
 *
 * <p>The slice-deps.properties file is generated by jbct:collect-slice-deps Maven goal
 * and maps API interface FQNs to artifact coordinates:
 * <pre>
 * # Key: interface FQN
 * # Value: groupId:artifactId:version
 * org.example.api.InventoryService=org.example:inventory:1.0.0
 * </pre>
 */
public class DependencyVersionResolver {
    private final ProcessingEnvironment env;
    private final Properties sliceDeps;
    private String currentSlicePackage;
    private String baseGroupId;
    private String baseArtifactId;

    public DependencyVersionResolver(ProcessingEnvironment env) {
        this.env = env;
        this.sliceDeps = loadSliceDeps();
    }

    /**
     * Set context for resolving local dependencies (same module).
     * Must be called before resolving dependencies for a slice.
     */
    public void setSliceContext(String slicePackage, String groupId, String artifactId) {
        this.currentSlicePackage = slicePackage;
        this.baseGroupId = groupId;
        this.baseArtifactId = artifactId;
    }

    public DependencyModel resolve(DependencyModel dependency) {
        var interfaceFqn = dependency.interfaceQualifiedName();
        if (interfaceFqn == null || interfaceFqn.isEmpty()) {
            return dependency.withResolved("unknown:unknown", "UNRESOLVED");
        }
        // Lookup by interface FQN
        var artifactCoords = sliceDeps.getProperty(interfaceFqn);
        if (artifactCoords == null) {
            // Try with .api suffix removed (in case interface is in api subpackage)
            var apiInterfaceFqn = interfaceFqn.replace(".api.", ".");
            artifactCoords = sliceDeps.getProperty(apiInterfaceFqn);
        }
        if (artifactCoords != null) {
            return parseCoordinates(dependency, artifactCoords);
        }
        // Fallback: derive from package (may be inaccurate)
        return fallbackResolve(dependency);
    }

    private DependencyModel parseCoordinates(DependencyModel dependency, String coords) {
        // Format: groupId:artifactId:version
        var parts = coords.split(":");
        if (parts.length >= 3) {
            var artifact = parts[0] + ":" + parts[1];
            var version = parts[2];
            return dependency.withResolved(artifact, version);
        } else if (parts.length == 2) {
            return dependency.withResolved(coords, "UNRESOLVED");
        }
        return dependency.withResolved("unknown:unknown", "UNRESOLVED");
    }

    private DependencyModel fallbackResolve(DependencyModel dependency) {
        var interfacePackage = dependency.interfacePackage();
        if (interfacePackage == null || interfacePackage.isEmpty()) {
            return dependency.withResolved("unknown:unknown", "UNRESOLVED");
        }
        // Check if this is a local dependency (same package as current slice)
        if (currentSlicePackage != null && interfacePackage.equals(currentSlicePackage)) {
            // Local dependency - use base artifact + slice name in kebab-case
            var sliceName = dependency.interfaceSimpleName();
            var kebabName = toKebabCase(sliceName);
            var artifact = baseGroupId + ":" + baseArtifactId + "-" + kebabName;
            return dependency.withResolved(artifact, "UNRESOLVED");
        }
        // External dependency - derive from package: org.example.inventory.api -> org.example:inventory
        var pkg = interfacePackage;
        // Remove .api suffix if present
        if (pkg.endsWith(".api")) {
            pkg = pkg.substring(0, pkg.length() - 4);
        }
        var parts = pkg.split("\\.");
        if (parts.length < 2) {
            return dependency.withResolved(pkg + ":unknown", "UNRESOLVED");
        }
        var groupId = String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1));
        var artifactId = parts[parts.length - 1];
        return dependency.withResolved(groupId + ":" + artifactId, "UNRESOLVED");
    }

    private static String toKebabCase(String camelCase) {
        if (camelCase == null || camelCase.isEmpty()) {
            return camelCase;
        }
        var result = new StringBuilder();
        result.append(Character.toLowerCase(camelCase.charAt(0)));
        for (int i = 1; i < camelCase.length(); i++) {
            char c = camelCase.charAt(i);
            if (Character.isUpperCase(c)) {
                result.append('-');
                result.append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

    private Properties loadSliceDeps() {
        var props = new Properties();
        try{
            FileObject resource = env.getFiler()
                                     .getResource(StandardLocation.CLASS_OUTPUT, "", "slice-deps.properties");
            try (var reader = resource.openReader(true)) {
                props.load(reader);
            }
            if (!props.isEmpty()) {
                env.getMessager()
                   .printMessage(Diagnostic.Kind.NOTE,
                                 "Loaded " + props.size() + " slice dependencies from slice-deps.properties");
            }
        } catch (IOException | IllegalArgumentException _) {
            // File might not exist yet (IOException) or filer doesn't support resource lookup
            // (IllegalArgumentException) - dependencies will remain unresolved
            env.getMessager()
               .printMessage(Diagnostic.Kind.NOTE,
                             "slice-deps.properties not found, dependency versions will be unresolved");
        }
        return props;
    }
}
