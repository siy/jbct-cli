package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;

import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.util.Properties;

/**
 * Resolves dependency artifact coordinates and versions from slice-deps.properties.
 *
 * <p>The slice-deps.properties file is generated by jbct:collect-slice-deps Maven goal
 * and maps API interface FQNs to artifact coordinates:
 * <pre>
 * # Key: interface FQN
 * # Value: groupId:artifactId:version
 * org.example.api.InventoryService=org.example:inventory:1.0.0
 * </pre>
 */
public class DependencyVersionResolver {
    private final ProcessingEnvironment env;
    private final Properties sliceDeps;

    public DependencyVersionResolver(ProcessingEnvironment env) {
        this.env = env;
        this.sliceDeps = loadSliceDeps();
    }

    public DependencyModel resolve(DependencyModel dependency) {
        var interfaceFqn = dependency.interfaceQualifiedName();
        if (interfaceFqn == null || interfaceFqn.isEmpty()) {
            return dependency.withResolved("unknown:unknown", "UNRESOLVED");
        }
        // Lookup by interface FQN
        var artifactCoords = sliceDeps.getProperty(interfaceFqn);
        if (artifactCoords == null) {
            // Try with .api suffix removed (in case interface is in api subpackage)
            var apiInterfaceFqn = interfaceFqn.replace(".api.", ".");
            artifactCoords = sliceDeps.getProperty(apiInterfaceFqn);
        }
        if (artifactCoords != null) {
            return parseCoordinates(dependency, artifactCoords);
        }
        // Fallback: derive from package (may be inaccurate)
        return fallbackResolve(dependency);
    }

    private DependencyModel parseCoordinates(DependencyModel dependency, String coords) {
        // Format: groupId:artifactId:version
        var parts = coords.split(":");
        if (parts.length >= 3) {
            var artifact = parts[0] + ":" + parts[1];
            var version = parts[2];
            return dependency.withResolved(artifact, version);
        } else if (parts.length == 2) {
            return dependency.withResolved(coords, "UNRESOLVED");
        }
        return dependency.withResolved("unknown:unknown", "UNRESOLVED");
    }

    private DependencyModel fallbackResolve(DependencyModel dependency) {
        var interfacePackage = dependency.interfacePackage();
        if (interfacePackage == null || interfacePackage.isEmpty()) {
            return dependency.withResolved("unknown:unknown", "UNRESOLVED");
        }
        // Derive artifact from package: org.example.inventory.api -> org.example:inventory
        var pkg = interfacePackage;
        // Remove .api suffix if present
        if (pkg.endsWith(".api")) {
            pkg = pkg.substring(0, pkg.length() - 4);
        }
        var parts = pkg.split("\\.");
        if (parts.length < 2) {
            return dependency.withResolved(pkg + ":unknown", "UNRESOLVED");
        }
        var groupId = String.join(".", java.util.Arrays.copyOf(parts, parts.length - 1));
        var artifactId = parts[parts.length - 1];
        return dependency.withResolved(groupId + ":" + artifactId, "UNRESOLVED");
    }

    private Properties loadSliceDeps() {
        var props = new Properties();
        try{
            FileObject resource = env.getFiler()
                                     .getResource(StandardLocation.CLASS_OUTPUT, "", "slice-deps.properties");
            try (var reader = resource.openReader(true)) {
                props.load(reader);
            }
            if (!props.isEmpty()) {
                env.getMessager()
                   .printMessage(Diagnostic.Kind.NOTE,
                                 "Loaded " + props.size() + " slice dependencies from slice-deps.properties");
            }
        } catch (IOException | IllegalArgumentException _) {
            // File might not exist yet (IOException) or filer doesn't support resource lookup
            // (IllegalArgumentException) - dependencies will remain unresolved
            env.getMessager()
               .printMessage(Diagnostic.Kind.NOTE,
                             "slice-deps.properties not found, dependency versions will be unresolved");
        }
        return props;
    }
}
