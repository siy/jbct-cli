package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Option;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Generates proxy classes for slice dependencies.
 * <p>
 * Proxies delegate all method calls to SliceInvokerFacade for remote invocation.
 * Supports methods with 0, 1, or multiple parameters.
 */
public class ProxyClassGenerator {
    private final Filer filer;
    private final Elements elements;
    private final Types types;

    private static final ClassName SLICE_INVOKER_FACADE = ClassName.get("org.pragmatica.aether.slice",
                                                                        "SliceInvokerFacade");
    private static final ClassName UNIT = ClassName.get("org.pragmatica.lang",
                                                        "Unit");

    public ProxyClassGenerator(Filer filer, Elements elements, Types types) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
    }

    public Result<Unit> generate(DependencyModel dependency, SliceModel context) {
        try{
            var proxyName = dependency.proxyClassName();
            var interfaceType = TypeName.get(dependency.interfaceType());
            var classBuilder = TypeSpec.classBuilder(proxyName)
                                       .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                                       .addSuperinterface(interfaceType)
                                       .addJavadoc("Proxy implementation of $L.\n",
                                                   dependency.interfaceSimpleName())
                                       .addJavadoc("Delegates all calls to SliceInvoker.\n")
                                       .addJavadoc("Generated by slice-processor - do not edit manually.\n");
            // Fields
            classBuilder.addField(SLICE_INVOKER_FACADE, "invoker", Modifier.PRIVATE, Modifier.FINAL);
            classBuilder.addField(String.class, "artifact", Modifier.PRIVATE, Modifier.FINAL);
            // Constructor
            classBuilder.addMethod(MethodSpec.constructorBuilder()
                                             .addModifiers(Modifier.PUBLIC)
                                             .addParameter(SLICE_INVOKER_FACADE, "invoker")
                                             .addParameter(String.class, "artifact")
                                             .addStatement("this.invoker = invoker")
                                             .addStatement("this.artifact = artifact")
                                             .build());
            // Methods - load interface to get method details
            var interfaceElement = elements.getTypeElement(dependency.interfaceQualifiedName());
            if (interfaceElement != null) {
                for (var enclosed : interfaceElement.getEnclosedElements()) {
                    if (enclosed.getKind() == ElementKind.METHOD) {
                        var method = (ExecutableElement) enclosed;
                        if (!method.getModifiers()
                                   .contains(Modifier.STATIC) &&
                        !method.getModifiers()
                               .contains(Modifier.DEFAULT)) {
                            var proxyMethodResult = generateProxyMethod(method);
                            if (proxyMethodResult.isFailure()) {
                                return proxyMethodResult.map(_ -> Unit.unit());
                            }
                            classBuilder.addMethod(proxyMethodResult.unwrap());
                        }
                    }
                }
            }
            // toString
            classBuilder.addMethod(MethodSpec.methodBuilder("toString")
                                             .addAnnotation(Override.class)
                                             .addModifiers(Modifier.PUBLIC)
                                             .returns(String.class)
                                             .addStatement("return $S + artifact + $S", proxyName + "[", "]")
                                             .build());
            var javaFile = JavaFile.builder(context.apiPackage(),
                                            classBuilder.build())
                                   .indent("    ")
                                   .build();
            javaFile.writeTo(filer);
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate proxy class: " + e.getMessage())
                         .result();
        }
    }

    private Result<MethodSpec> generateProxyMethod(ExecutableElement method) {
        var methodName = method.getSimpleName()
                               .toString();
        var returnType = method.getReturnType();
        var params = method.getParameters();
        // Extract response type from Promise<T>
        var responseType = extractPromiseTypeArg(returnType);
        if (responseType.isEmpty()) {
            return Causes.cause("Method " + methodName + " must return Promise<T>")
                         .result();
        }
        var builder = MethodSpec.methodBuilder(methodName)
                                .addAnnotation(Override.class)
                                .addModifiers(Modifier.PUBLIC)
                                .returns(TypeName.get(returnType));
        // Add all parameters
        for (var param : params) {
            builder.addParameter(TypeName.get(param.asType()),
                                 param.getSimpleName()
                                      .toString());
        }
        // Generate invocation based on parameter count
        var responseTypeClass = responseType.unwrap();
        switch (params.size()) {
            case 0 -> builder.addStatement("return invoker.invokeAndWait(artifact, $S, $T.unit(), $T.class)",
                                           methodName,
                                           UNIT,
                                           responseTypeClass);
            case 1 -> {
                var paramName = params.getFirst()
                                      .getSimpleName()
                                      .toString();
                builder.addStatement("return invoker.invokeAndWait(artifact, $S, $L, $T.class)",
                                     methodName,
                                     paramName,
                                     responseTypeClass);
            }
            default -> {
                // Multiple params - create inline record to wrap them
                var paramNames = params.stream()
                                       .map(p -> p.getSimpleName()
                                                  .toString())
                                       .toList();
                var recordFields = String.join(", ", paramNames);
                builder.addStatement("return invoker.invokeAndWait(artifact, $S, new Object[]{$L}, $T.class)",
                                     methodName,
                                     recordFields,
                                     responseTypeClass);
            }
        }
        return Result.success(builder.build());
    }

    private Option<TypeMirror> extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return Option.some(typeArgs.getFirst());
            }
        }
        return Option.none();
    }
}
