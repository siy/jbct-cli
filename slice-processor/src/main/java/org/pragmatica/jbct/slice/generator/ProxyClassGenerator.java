package org.pragmatica.jbct.slice.generator;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.SliceModel;

import javax.annotation.processing.Filer;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;

public class ProxyClassGenerator {

    private final Filer filer;
    private final Elements elements;
    private final Types types;

    private static final ClassName SLICE_INVOKER_FACADE = ClassName.get(
        "org.pragmatica.aether.slice", "SliceInvokerFacade");

    public ProxyClassGenerator(Filer filer, Elements elements, Types types) {
        this.filer = filer;
        this.elements = elements;
        this.types = types;
    }

    public void generate(DependencyModel dependency, SliceModel context) throws IOException {
        var proxyName = dependency.proxyClassName();
        var interfaceType = TypeName.get(dependency.interfaceType());

        var classBuilder = TypeSpec.classBuilder(proxyName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addSuperinterface(interfaceType)
            .addJavadoc("Proxy implementation of $L.\n", dependency.interfaceSimpleName())
            .addJavadoc("Delegates all calls to SliceInvoker.\n")
            .addJavadoc("Generated by slice-processor - do not edit manually.\n");

        // Fields
        classBuilder.addField(SLICE_INVOKER_FACADE, "invoker", Modifier.PRIVATE, Modifier.FINAL);
        classBuilder.addField(String.class, "artifact", Modifier.PRIVATE, Modifier.FINAL);

        // Constructor
        classBuilder.addMethod(MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SLICE_INVOKER_FACADE, "invoker")
            .addParameter(String.class, "artifact")
            .addStatement("this.invoker = invoker")
            .addStatement("this.artifact = artifact")
            .build());

        // Methods - load interface to get method details
        var interfaceElement = elements.getTypeElement(dependency.interfaceQualifiedName());
        if (interfaceElement != null) {
            for (var enclosed : interfaceElement.getEnclosedElements()) {
                if (enclosed.getKind() == ElementKind.METHOD) {
                    var method = (ExecutableElement) enclosed;
                    if (!method.getModifiers().contains(Modifier.STATIC) &&
                        !method.getModifiers().contains(Modifier.DEFAULT)) {
                        classBuilder.addMethod(generateProxyMethod(method));
                    }
                }
            }
        }

        // toString
        classBuilder.addMethod(MethodSpec.methodBuilder("toString")
            .addAnnotation(Override.class)
            .addModifiers(Modifier.PUBLIC)
            .returns(String.class)
            .addStatement("return $S + artifact + $S", proxyName + "[", "]")
            .build());

        var javaFile = JavaFile.builder(context.apiPackage(), classBuilder.build())
            .indent("    ")
            .build();

        javaFile.writeTo(filer);
    }

    private MethodSpec generateProxyMethod(ExecutableElement method) {
        var methodName = method.getSimpleName().toString();
        var returnType = method.getReturnType();
        var params = method.getParameters();

        if (params.size() != 1) {
            throw new IllegalStateException("Proxy method must have exactly one parameter: " + methodName);
        }

        var param = params.getFirst();
        var paramType = param.asType();
        var paramName = param.getSimpleName().toString();

        // Extract response type from Promise<T>
        var responseType = extractPromiseTypeArg(returnType);

        return MethodSpec.methodBuilder(methodName)
            .addAnnotation(Override.class)
            .addModifiers(Modifier.PUBLIC)
            .returns(TypeName.get(returnType))
            .addParameter(TypeName.get(paramType), paramName)
            .addStatement("return invoker.invokeAndWait(artifact, $S, $L, $T.class)",
                methodName, paramName, responseType)
            .build();
    }

    private TypeMirror extractPromiseTypeArg(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var typeArgs = dt.getTypeArguments();
            if (!typeArgs.isEmpty()) {
                return typeArgs.getFirst();
            }
        }
        throw new IllegalStateException("Return type must be Promise<T>");
    }
}
