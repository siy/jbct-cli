package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.DependencyModel;
import org.pragmatica.jbct.slice.model.MethodModel;
import org.pragmatica.jbct.slice.model.SliceModel;
import org.pragmatica.lang.Result;
import org.pragmatica.lang.Unit;
import org.pragmatica.lang.utils.Causes;

import javax.annotation.processing.Filer;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.tools.StandardLocation;
import java.io.OutputStreamWriter;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.stream.Collectors;

public class ManifestGenerator {
    private final Filer filer;
    private final DependencyVersionResolver versionResolver;
    private final Map<String, String> options;

    public ManifestGenerator(Filer filer, DependencyVersionResolver versionResolver, Map<String, String> options) {
        this.filer = filer;
        this.versionResolver = versionResolver;
        this.options = options;
    }

    public Result<Unit> generate(SliceModel model) {
        try{
            var props = new Properties();
            // API artifact (with classifier)
            props.setProperty("api.artifact", getArtifactFromEnv() + ":api");
            // Slice artifact (without classifier)
            props.setProperty("slice.artifact", getArtifactFromEnv());
            // API interface fully qualified name
            props.setProperty("api.interface",
                              model.apiPackage() + "." + model.simpleName());
            // Implementation interface fully qualified name
            props.setProperty("impl.interface", model.qualifiedName());
            // Metadata
            props.setProperty("generated.timestamp",
                              Instant.now()
                                     .toString());
            props.setProperty("processor.version", getProcessorVersion());
            // Write to META-INF/slice-api.properties
            var resource = filer.createResource(StandardLocation.CLASS_OUTPUT, "", "META-INF/slice-api.properties");
            try (var writer = new OutputStreamWriter(resource.openOutputStream())) {
                props.store(writer, "Slice API manifest - generated by slice-processor");
            }
            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate manifest: " + e.getMessage())
                         .result();
        }
    }

    private String getArtifactFromEnv() {
        var groupId = options.getOrDefault("slice.groupId", "unknown");
        var artifactId = options.getOrDefault("slice.artifactId", "unknown");
        return groupId + ":" + artifactId;
    }

    private String getProcessorVersion() {
        var version = getClass()
                              .getPackage()
                              .getImplementationVersion();
        return version != null
               ? version
               : "dev";
    }

    /**
     * Generate per-slice manifest with class listings for multi-artifact packaging.
     * Written to META-INF/slice/{SliceName}.manifest
     */
    public Result<Unit> generateSliceManifest(SliceModel model) {
        try {
            var props = new Properties();
            var sliceName = model.simpleName();

            // Slice identification
            props.setProperty("slice.name", sliceName);
            props.setProperty("slice.artifactSuffix", toKebabCase(sliceName));
            props.setProperty("slice.package", model.packageName());

            // API classes (just the generated API interface)
            var apiClass = model.apiPackage() + "." + sliceName;
            props.setProperty("api.classes", apiClass);

            // Implementation classes
            var implClasses = collectImplClasses(model);
            props.setProperty("impl.classes", String.join(",", implClasses));

            // Request/Response types from methods
            var requestTypes = collectRequestTypes(model);
            var responseTypes = collectResponseTypes(model);
            props.setProperty("request.classes", String.join(",", requestTypes));
            props.setProperty("response.classes", String.join(",", responseTypes));

            // Artifact coordinates
            props.setProperty("base.artifact", getArtifactFromEnv());
            props.setProperty("api.artifactId", getArtifactIdFromEnv() + "-" + toKebabCase(sliceName) + "-api");
            props.setProperty("impl.artifactId", getArtifactIdFromEnv() + "-" + toKebabCase(sliceName));

            // Dependencies for blueprint generation
            var dependencies = model.dependencies();
            props.setProperty("dependencies.count", String.valueOf(dependencies.size()));

            int index = 0;
            for (var dep : dependencies) {
                var prefix = "dependency." + index + ".";
                var isExternal = dep.isExternal(model.packageName());
                props.setProperty(prefix + "interface", dep.interfaceQualifiedName());
                props.setProperty(prefix + "external", String.valueOf(isExternal));

                if (isExternal) {
                    var resolved = versionResolver.resolve(dep);
                    props.setProperty(prefix + "artifact", resolved.sliceArtifact().or(() -> ""));
                    props.setProperty(prefix + "version", resolved.version().or(() -> "UNRESOLVED"));
                } else {
                    props.setProperty(prefix + "artifact", "");
                    props.setProperty(prefix + "version", "");
                }
                index++;
            }

            // Slice config file path (for blueprint generator to read)
            props.setProperty("config.file", "slices/" + sliceName + ".toml");

            // Metadata
            props.setProperty("generated.timestamp", Instant.now().toString());
            props.setProperty("processor.version", getProcessorVersion());

            // Write to META-INF/slice/{SliceName}.manifest
            var resourcePath = "META-INF/slice/" + sliceName + ".manifest";
            var resource = filer.createResource(StandardLocation.CLASS_OUTPUT, "", resourcePath);
            try (var writer = new OutputStreamWriter(resource.openOutputStream())) {
                props.store(writer, "Slice manifest for " + sliceName + " - generated by slice-processor");
            }

            return Result.success(Unit.unit());
        } catch (Exception e) {
            return Causes.cause("Failed to generate slice manifest: " + e.getMessage())
                         .result();
        }
    }

    private List<String> collectImplClasses(SliceModel model) {
        var classes = new ArrayList<String>();

        // Original @Slice interface
        classes.add(model.qualifiedName());

        // Generated factory class
        classes.add(model.packageName() + "." + model.simpleName() + "Factory");

        // Factory inner classes (adapter record for createSlice)
        var adapterName = Character.toLowerCase(model.simpleName().charAt(0))
                          + model.simpleName().substring(1) + "Slice";
        classes.add(model.packageName() + "." + model.simpleName() + "Factory$" + adapterName);

        // Proxy records for external dependencies
        for (var dep : model.dependencies()) {
            if (dep.isExternal(model.packageName())) {
                classes.add(model.packageName() + "." + model.simpleName() + "Factory$" + dep.localRecordName());
            }
        }

        return classes;
    }

    private List<String> collectRequestTypes(SliceModel model) {
        return model.methods()
                    .stream()
                    .map(MethodModel::parameterType)
                    .map(this::getQualifiedTypeName)
                    .filter(name -> !isStandardType(name))
                    .distinct()
                    .collect(Collectors.toList());
    }

    private List<String> collectResponseTypes(SliceModel model) {
        return model.methods()
                    .stream()
                    .map(MethodModel::responseType)
                    .map(this::getQualifiedTypeName)
                    .filter(name -> !isStandardType(name))
                    .distinct()
                    .collect(Collectors.toList());
    }

    private String getQualifiedTypeName(TypeMirror type) {
        if (type instanceof DeclaredType dt) {
            var element = dt.asElement();
            return element.toString();
        }
        return type.toString();
    }

    private boolean isStandardType(String typeName) {
        return typeName.startsWith("java.lang.")
               || typeName.startsWith("java.util.")
               || typeName.equals("void")
               || typeName.equals("int")
               || typeName.equals("long")
               || typeName.equals("boolean")
               || typeName.equals("double")
               || typeName.equals("float");
    }

    private String getArtifactIdFromEnv() {
        return options.getOrDefault("slice.artifactId", "unknown");
    }

    /**
     * Convert PascalCase to kebab-case.
     * Examples: OrderService -> order-service, PlaceOrder -> place-order
     */
    private String toKebabCase(String pascalCase) {
        if (pascalCase == null || pascalCase.isEmpty()) {
            return pascalCase;
        }

        var result = new StringBuilder();
        for (int i = 0; i < pascalCase.length(); i++) {
            char c = pascalCase.charAt(i);
            if (Character.isUpperCase(c)) {
                if (i > 0) {
                    result.append('-');
                }
                result.append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
}
