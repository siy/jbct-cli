package org.pragmatica.jbct.slice.generator;

import org.pragmatica.jbct.slice.model.SliceModel;

import javax.annotation.processing.Filer;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.time.Instant;
import java.util.Properties;

public class ManifestGenerator {

    private final Filer filer;

    public ManifestGenerator(Filer filer) {
        this.filer = filer;
    }

    public void generate(SliceModel model) throws IOException {
        var props = new Properties();

        // API artifact (with classifier)
        props.setProperty("api.artifact", getArtifactFromEnv() + ":api");

        // Slice artifact (without classifier)
        props.setProperty("slice.artifact", getArtifactFromEnv());

        // API interface fully qualified name
        props.setProperty("api.interface", model.apiPackage() + "." + model.simpleName());

        // Implementation interface fully qualified name
        props.setProperty("impl.interface", model.qualifiedName());

        // Metadata
        props.setProperty("generated.timestamp", Instant.now().toString());
        props.setProperty("processor.version", getProcessorVersion());

        // Write to META-INF/slice-api.properties
        var resource = filer.createResource(
            StandardLocation.CLASS_OUTPUT,
            "",
            "META-INF/slice-api.properties"
        );

        try (var writer = new OutputStreamWriter(resource.openOutputStream())) {
            props.store(writer, "Slice API manifest - generated by slice-processor");
        }
    }

    private String getArtifactFromEnv() {
        var groupId = System.getProperty("slice.groupId", "unknown");
        var artifactId = System.getProperty("slice.artifactId", "unknown");
        return groupId + ":" + artifactId;
    }

    private String getProcessorVersion() {
        var version = getClass().getPackage().getImplementationVersion();
        return version != null ? version : "dev";
    }
}
