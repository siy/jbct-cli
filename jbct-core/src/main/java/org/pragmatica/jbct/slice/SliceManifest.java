package org.pragmatica.jbct.slice;

import org.pragmatica.lang.Result;
import org.pragmatica.lang.utils.Causes;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Model for per-slice manifest files generated by slice-processor.
 * Used by Maven plugin to package slices into separate artifacts.
 */
public record SliceManifest(String sliceName,
                            String artifactSuffix,
                            String slicePackage,
                            List<String> implClasses,
                            List<String> requestClasses,
                            List<String> responseClasses,
                            String baseArtifact,
                            String implArtifactId,
                            List<SliceDependency> dependencies,
                            String configFile) {
    public SliceManifest {
        implClasses = List.copyOf(implClasses);
        requestClasses = List.copyOf(requestClasses);
        responseClasses = List.copyOf(responseClasses);
        dependencies = List.copyOf(dependencies);
    }

    /**
     * Dependency information for blueprint generation.
     */
    public record SliceDependency(String interfaceQualifiedName,
                                  String artifact,
                                  String version,
                                  boolean external) {
        public static SliceDependency sliceDependency(String interfaceQualifiedName,
                                                      String artifact,
                                                      String version,
                                                      boolean external) {
            return new SliceDependency(interfaceQualifiedName, artifact, version, external);
        }
    }

    /**
     * Load a slice manifest from a .manifest file.
     */
    public static Result<SliceManifest> load(Path manifestPath) {
        try (var input = Files.newInputStream(manifestPath)) {
            return load(input);
        } catch (IOException e) {
            return Causes.cause("Failed to read manifest: " + e.getMessage())
                         .result();
        }
    }

    /**
     * Load a slice manifest from an input stream.
     */
    public static Result<SliceManifest> load(InputStream input) {
        try{
            var props = new Properties();
            props.load(input);
            return fromProperties(props);
        } catch (IOException e) {
            return Causes.cause("Failed to parse manifest: " + e.getMessage())
                         .result();
        }
    }

    private static Result<SliceManifest> fromProperties(Properties props) {
        var sliceName = props.getProperty("slice.name");
        if (sliceName == null || sliceName.isEmpty()) {
            return Causes.cause("Missing required property: slice.name")
                         .result();
        }
        var artifactSuffix = props.getProperty("slice.artifactSuffix", "");
        var slicePackage = props.getProperty("slice.package", "");
        var implClasses = parseList(props.getProperty("impl.classes", ""));
        var requestClasses = parseList(props.getProperty("request.classes", ""));
        var responseClasses = parseList(props.getProperty("response.classes", ""));
        var baseArtifact = props.getProperty("base.artifact", "");
        var implArtifactId = props.getProperty("slice.artifactId", "");
        var dependencies = parseDependencies(props);
        var configFile = props.getProperty("config.file", "");
        return Result.success(new SliceManifest(sliceName,
                                                artifactSuffix,
                                                slicePackage,
                                                implClasses,
                                                requestClasses,
                                                responseClasses,
                                                baseArtifact,
                                                implArtifactId,
                                                dependencies,
                                                configFile));
    }

    private static final Logger LOG = LoggerFactory.getLogger(SliceManifest.class);

    private static List<SliceDependency> parseDependencies(Properties props) {
        var countStr = props.getProperty("dependencies.count", "0");
        int count;
        try{
            count = Integer.parseInt(countStr);
        } catch (NumberFormatException e) {
            LOG.warn("Invalid dependencies.count value '{}' in manifest, using 0", countStr);
            return List.of();
        }
        var dependencies = new java.util.ArrayList<SliceDependency>();
        for (int i = 0; i < count; i++) {
            var prefix = "dependency." + i + ".";
            var interfaceName = props.getProperty(prefix + "interface", "");
            var artifact = props.getProperty(prefix + "artifact", "");
            var version = props.getProperty(prefix + "version", "");
            var external = Boolean.parseBoolean(props.getProperty(prefix + "external", "false"));
            if (!interfaceName.isEmpty()) {
                dependencies.add(SliceDependency.sliceDependency(interfaceName, artifact, version, external));
            }
        }
        return dependencies;
    }

    private static List<String> parseList(String value) {
        if (value == null || value.isEmpty()) {
            return List.of();
        }
        return Arrays.stream(value.split(","))
                     .map(String::trim)
                     .filter(s -> !s.isEmpty())
                     .toList();
    }

    /**
     * Get all classes that should go into the impl artifact.
     * Includes implementation classes, request types, and response types.
     */
    public List<String> allImplClasses() {
        var all = new java.util.ArrayList<>(implClasses);
        all.addAll(requestClasses);
        all.addAll(responseClasses);
        return all;
    }

    /**
     * Convert class name to class file path (relative).
     * Handles nested classes: OuterClass.InnerClass -> OuterClass$InnerClass
     * Uses heuristic: package parts are lowercase, class names start uppercase.
     * Example: org.example.MyClass -> org/example/MyClass.class
     * Example: org.example.MyClass.Inner -> org/example/MyClass$Inner.class
     */
    public static String classToPath(String className) {
        return classNameToFilePath(className) + ".class";
    }

    /**
     * Convert fully qualified class name to file path (without .class extension).
     * Package dots become /, nested class dots become $.
     */
    private static String classNameToFilePath(String className) {
        var parts = className.split("\\.");
        var sb = new StringBuilder();
        var inClassName = false;
        for (int i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i > 0) {
                sb.append(inClassName
                          ? '$'
                          : '/');
            }
            sb.append(part);
            if (!inClassName && !part.isEmpty() && Character.isUpperCase(part.charAt(0))) {
                inClassName = true;
            }
        }
        return sb.toString();
    }

    /**
     * Convert class name to all possible class file paths (including inner classes).
     * Example: org.example.MyClass$Inner -> org/example/MyClass$Inner.class
     */
    public static List<String> classToPathsWithInner(String className, Path classesDir) {
        var basePath = classNameToFilePath(className);
        var baseFile = classesDir.resolve(basePath + ".class");
        if (!Files.exists(baseFile)) {
            return List.of();
        }
        var result = new java.util.ArrayList<String>();
        result.add(basePath + ".class");
        // Find inner classes (ClassName$*.class)
        try{
            var parent = baseFile.getParent();
            var simpleName = baseFile.getFileName()
                                     .toString()
                                     .replace(".class", "");
            try (var stream = Files.list(parent)) {
                stream.filter(p -> p.getFileName()
                                    .toString()
                                    .startsWith(simpleName + "$"))
                      .filter(p -> p.getFileName()
                                    .toString()
                                    .endsWith(".class"))
                      .forEach(p -> {
                                   var relativePath = classesDir.relativize(p)
                                                                .toString();
                                   result.add(relativePath.replace('\\', '/'));
                               });
            }
        } catch (IOException e) {
            LOG.debug("Failed to list inner classes for {}: {}", className, e.getMessage());
        }
        return result;
    }
}
