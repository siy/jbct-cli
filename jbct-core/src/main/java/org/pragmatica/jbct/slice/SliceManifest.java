package org.pragmatica.jbct.slice;

import org.pragmatica.lang.Result;
import org.pragmatica.lang.utils.Causes;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Model for per-slice manifest files generated by slice-processor.
 * Used by Maven plugin to package slices into separate artifacts.
 */
public record SliceManifest(String sliceName,
                            String artifactSuffix,
                            String slicePackage,
                            List<String> implClasses,
                            List<String> requestClasses,
                            List<String> responseClasses,
                            String baseArtifact,
                            String implArtifactId,
                            List<SliceDependency> dependencies,
                            String configFile) {
    public SliceManifest {
        implClasses = List.copyOf(implClasses);
        requestClasses = List.copyOf(requestClasses);
        responseClasses = List.copyOf(responseClasses);
        dependencies = List.copyOf(dependencies);
    }

    /**
     * Dependency information for blueprint generation.
     */
    public record SliceDependency(String interfaceQualifiedName,
                                  String artifact,
                                  String version,
                                  boolean external) {
        public static SliceDependency sliceDependency(String interfaceQualifiedName,
                                                      String artifact,
                                                      String version,
                                                      boolean external) {
            return new SliceDependency(interfaceQualifiedName, artifact, version, external);
        }
    }

    /**
     * Load a slice manifest from a .manifest file.
     */
    public static Result<SliceManifest> load(Path manifestPath) {
        try (var input = Files.newInputStream(manifestPath)) {
            return load(input);
        } catch (IOException e) {
            return Causes.cause("Failed to read manifest: " + e.getMessage())
                         .result();
        }
    }

    /**
     * Load a slice manifest from an input stream.
     */
    public static Result<SliceManifest> load(InputStream input) {
        try{
            var props = new Properties();
            props.load(input);
            return fromProperties(props);
        } catch (IOException e) {
            return Causes.cause("Failed to parse manifest: " + e.getMessage())
                         .result();
        }
    }

    private static Result<SliceManifest> fromProperties(Properties props) {
        return org.pragmatica.lang.Option.option(props.getProperty("slice.name"))
                                         .filter(s -> !s.isEmpty())
                                         .toResult(Causes.cause("Missing required property: slice.name"))
                                         .map(sliceName -> buildManifest(sliceName, props));
    }

    private static SliceManifest buildManifest(String sliceName, Properties props) {
        var artifactSuffix = getPropertyOrEmpty(props, "slice.artifactSuffix");
        var slicePackage = getPropertyOrEmpty(props, "slice.package");
        var implClasses = parseList(getPropertyOrEmpty(props, "impl.classes"));
        var requestClasses = parseList(getPropertyOrEmpty(props, "request.classes"));
        var responseClasses = parseList(getPropertyOrEmpty(props, "response.classes"));
        var baseArtifact = getPropertyOrEmpty(props, "base.artifact");
        var implArtifactId = getPropertyOrEmpty(props, "slice.artifactId");
        var dependencies = parseDependencies(props);
        var configFile = getPropertyOrEmpty(props, "config.file");
        return new SliceManifest(sliceName,
                                 artifactSuffix,
                                 slicePackage,
                                 implClasses,
                                 requestClasses,
                                 responseClasses,
                                 baseArtifact,
                                 implArtifactId,
                                 dependencies,
                                 configFile);
    }

    private static String getPropertyOrEmpty(Properties props, String key) {
        return org.pragmatica.lang.Option.option(props.getProperty(key))
                                         .or("");
    }

    private static final Logger LOG = LoggerFactory.getLogger(SliceManifest.class);

    private static List<SliceDependency> parseDependencies(Properties props) {
        var countStr = props.getProperty("dependencies.count", "0");
        int count;
        try{
            count = Integer.parseInt(countStr);
        } catch (NumberFormatException e) {
            LOG.warn("Invalid dependencies.count value '{}' in manifest, using 0", countStr);
            return List.of();
        }
        var dependencies = new java.util.ArrayList<SliceDependency>();
        for (int i = 0; i < count; i++) {
            var prefix = "dependency." + i + ".";
            var interfaceName = props.getProperty(prefix + "interface", "");
            var artifact = props.getProperty(prefix + "artifact", "");
            var version = props.getProperty(prefix + "version", "");
            var external = Boolean.parseBoolean(props.getProperty(prefix + "external", "false"));
            if (!interfaceName.isEmpty()) {
                dependencies.add(SliceDependency.sliceDependency(interfaceName, artifact, version, external));
            }
        }
        return dependencies;
    }

    private static List<String> parseList(String value) {
        return org.pragmatica.lang.Option.option(value)
                                         .filter(s -> !s.isEmpty())
                                         .map(s -> Arrays.stream(s.split(","))
                                                         .map(String::trim)
                                                         .filter(part -> !part.isEmpty())
                                                         .toList())
                                         .or(List.of());
    }

    /**
     * Get all classes that should go into the impl artifact.
     * Includes implementation classes, request types, and response types.
     */
    public List<String> allImplClasses() {
        var all = new java.util.ArrayList<>(implClasses);
        all.addAll(requestClasses);
        all.addAll(responseClasses);
        return all;
    }

    /**
     * Convert class name to class file path (relative).
     * Handles nested classes: OuterClass.InnerClass -> OuterClass$InnerClass
     * Uses heuristic: package parts are lowercase, class names start uppercase.
     * Example: org.example.MyClass -> org/example/MyClass.class
     * Example: org.example.MyClass.Inner -> org/example/MyClass$Inner.class
     */
    public static String classToPath(String className) {
        return classNameToFilePath(className) + ".class";
    }

    /**
     * Convert fully qualified class name to file path (without .class extension).
     * Package dots become /, nested class dots become $.
     */
    private static String classNameToFilePath(String className) {
        var parts = className.split("\\.");
        var sb = new StringBuilder();
        var inClassName = false;
        for (int i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i > 0) {
                sb.append(inClassName
                          ? '$'
                          : '/');
            }
            sb.append(part);
            if (!inClassName && !part.isEmpty() && Character.isUpperCase(part.charAt(0))) {
                inClassName = true;
            }
        }
        return sb.toString();
    }

    /**
     * Convert class name to all possible class file paths (including inner classes).
     * Example: org.example.MyClass$Inner -> org/example/MyClass$Inner.class
     */
    public static List<String> classToPathsWithInner(String className, Path classesDir) {
        var basePath = classNameToFilePath(className);
        var baseFile = classesDir.resolve(basePath + ".class");
        if (!Files.exists(baseFile)) {
            return List.of();
        }
        var result = new java.util.ArrayList<String>();
        result.add(basePath + ".class");
        // Find inner classes (ClassName$*.class)
        try{
            var parent = baseFile.getParent();
            var simpleName = baseFile.getFileName()
                                     .toString()
                                     .replace(".class", "");
            try (var stream = Files.list(parent)) {
                stream.filter(p -> p.getFileName()
                                    .toString()
                                    .startsWith(simpleName + "$"))
                      .filter(p -> p.getFileName()
                                    .toString()
                                    .endsWith(".class"))
                      .forEach(p -> {
                                   var relativePath = classesDir.relativize(p)
                                                                .toString();
                                   result.add(relativePath.replace('\\', '/'));
                               });
            }
        } catch (IOException e) {
            LOG.debug("Failed to list inner classes for {}: {}", className, e.getMessage());
        }
        return result;
    }
}
