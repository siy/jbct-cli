package org.pragmatica.jbct.slice;

import org.pragmatica.lang.Result;
import org.pragmatica.lang.utils.Causes;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

/**
 * Model for per-slice manifest files generated by slice-processor.
 * Used by Maven plugin to package slices into separate artifacts.
 */
public record SliceManifest(String sliceName,
                            String artifactSuffix,
                            String slicePackage,
                            List<String> apiClasses,
                            List<String> implClasses,
                            List<String> requestClasses,
                            List<String> responseClasses,
                            String baseArtifact,
                            String apiArtifactId,
                            String implArtifactId,
                            List<SliceDependency> dependencies) {

    /**
     * Dependency information for blueprint generation.
     */
    public record SliceDependency(String interfaceQualifiedName,
                                   String artifact,
                                   String version,
                                   boolean external) {}

    /**
     * Load a slice manifest from a .manifest file.
     */
    public static Result<SliceManifest> load(Path manifestPath) {
        try (var input = Files.newInputStream(manifestPath)) {
            return load(input);
        } catch (IOException e) {
            return Causes.cause("Failed to read manifest: " + e.getMessage()).result();
        }
    }

    /**
     * Load a slice manifest from an input stream.
     */
    public static Result<SliceManifest> load(InputStream input) {
        try {
            var props = new Properties();
            props.load(input);
            return fromProperties(props);
        } catch (IOException e) {
            return Causes.cause("Failed to parse manifest: " + e.getMessage()).result();
        }
    }

    private static Result<SliceManifest> fromProperties(Properties props) {
        var sliceName = props.getProperty("slice.name");
        if (sliceName == null || sliceName.isEmpty()) {
            return Causes.cause("Missing required property: slice.name").result();
        }

        var artifactSuffix = props.getProperty("slice.artifactSuffix", "");
        var slicePackage = props.getProperty("slice.package", "");
        var apiClasses = parseList(props.getProperty("api.classes", ""));
        var implClasses = parseList(props.getProperty("impl.classes", ""));
        var requestClasses = parseList(props.getProperty("request.classes", ""));
        var responseClasses = parseList(props.getProperty("response.classes", ""));
        var baseArtifact = props.getProperty("base.artifact", "");
        var apiArtifactId = props.getProperty("api.artifactId", "");
        var implArtifactId = props.getProperty("impl.artifactId", "");
        var dependencies = parseDependencies(props);

        return Result.success(new SliceManifest(
                sliceName,
                artifactSuffix,
                slicePackage,
                apiClasses,
                implClasses,
                requestClasses,
                responseClasses,
                baseArtifact,
                apiArtifactId,
                implArtifactId,
                dependencies
        ));
    }

    private static List<SliceDependency> parseDependencies(Properties props) {
        var count = Integer.parseInt(props.getProperty("dependencies.count", "0"));
        var dependencies = new java.util.ArrayList<SliceDependency>();

        for (int i = 0; i < count; i++) {
            var prefix = "dependency." + i + ".";
            var interfaceName = props.getProperty(prefix + "interface", "");
            var artifact = props.getProperty(prefix + "artifact", "");
            var version = props.getProperty(prefix + "version", "");
            var external = Boolean.parseBoolean(props.getProperty(prefix + "external", "false"));

            if (!interfaceName.isEmpty()) {
                dependencies.add(new SliceDependency(interfaceName, artifact, version, external));
            }
        }

        return dependencies;
    }

    private static List<String> parseList(String value) {
        if (value == null || value.isEmpty()) {
            return List.of();
        }
        return Arrays.stream(value.split(","))
                     .map(String::trim)
                     .filter(s -> !s.isEmpty())
                     .toList();
    }

    /**
     * Get all classes that should go into the API artifact.
     */
    public List<String> allApiClasses() {
        return apiClasses;
    }

    /**
     * Get all classes that should go into the impl artifact.
     * Includes impl classes, request/response types.
     */
    public List<String> allImplClasses() {
        var all = new java.util.ArrayList<>(implClasses);
        all.addAll(requestClasses);
        all.addAll(responseClasses);
        return all;
    }

    /**
     * Convert class name to class file path (relative).
     * Example: org.example.MyClass -> org/example/MyClass.class
     */
    public static String classToPath(String className) {
        return className.replace('.', '/') + ".class";
    }

    /**
     * Convert class name to all possible class file paths (including inner classes).
     * Example: org.example.MyClass$Inner -> org/example/MyClass$Inner.class
     */
    public static List<String> classToPathsWithInner(String className, Path classesDir) {
        var basePath = className.replace('.', '/');
        var baseFile = classesDir.resolve(basePath + ".class");

        if (!Files.exists(baseFile)) {
            return List.of();
        }

        var result = new java.util.ArrayList<String>();
        result.add(basePath + ".class");

        // Find inner classes (ClassName$*.class)
        try {
            var parent = baseFile.getParent();
            var simpleName = baseFile.getFileName().toString().replace(".class", "");
            try (var stream = Files.list(parent)) {
                stream.filter(p -> p.getFileName().toString().startsWith(simpleName + "$"))
                      .filter(p -> p.getFileName().toString().endsWith(".class"))
                      .forEach(p -> {
                          var relativePath = classesDir.relativize(p).toString();
                          result.add(relativePath.replace('\\', '/'));
                      });
            }
        } catch (IOException e) {
            // Ignore - just return base class
        }

        return result;
    }
}
