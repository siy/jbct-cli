package org.pragmatica.jbct.maven;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.jar.JarFile;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

/**
 * Scans compile dependencies for slice manifests and writes interface-to-artifact mappings.
 * This allows the annotation processor to resolve slice dependency versions.
 *
 * <p>For each dependency JAR containing META-INF/slice/*.manifest files, extracts:
 * <ul>
 *   <li>slice.interface - the slice interface fully qualified name</li>
 *   <li>slice.artifactId - the slice artifact ID</li>
 * </ul>
 *
 * <p>Writes mappings to slice-deps.properties in format:
 * <pre>
 * # Key: interface qualified name
 * # Value: groupId:artifactId:version
 * org.example.api.InventoryService=org.example:inventory-service:1.0.0
 * </pre>
 */
@Mojo(name = "collect-slice-deps",
 defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 requiresDependencyResolution = ResolutionScope.COMPILE)
public class CollectSliceDepsMojo extends AbstractMojo {
    private static final String MANIFEST_DIR = "META-INF/slice/";

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;

    @Parameter(property = "jbct.outputFile",
    defaultValue = "${project.build.outputDirectory}/slice-deps.properties")
    private File outputFile;

    @Parameter(property = "jbct.skip", defaultValue = "false")
    private boolean skip;

    @Override
    public void execute() throws MojoExecutionException {
        if (skip) {
            getLog().info("Skipping slice dependency collection");
            return;
        }
        var mappings = new Properties();
        for (var artifact : project.getArtifacts()) {
            var file = artifact.getFile();
            if (file == null || !file.exists() || !file.getName()
                                                       .endsWith(".jar")) {
                continue;
            }
            try{
                extractSliceManifest(file, artifact.getVersion(), mappings);
            } catch (IOException e) {
                getLog().debug("Could not read JAR: " + file + " - " + e.getMessage());
            }
        }
        writeOutput(mappings);
    }

    private void extractSliceManifest(File jarFile, String version, Properties mappings) throws IOException {
        try (var jar = new JarFile(jarFile)) {
            var entries = jar.entries();
            while (entries.hasMoreElements()) {
                var entry = entries.nextElement();
                var entryName = entry.getName();
                if (!entryName.startsWith(MANIFEST_DIR) || !entryName.endsWith(".manifest")) {
                    continue;
                }
                var props = new Properties();
                try (var stream = jar.getInputStream(entry)) {
                    props.load(stream);
                }
                var sliceInterface = props.getProperty("slice.interface");
                var sliceArtifactId = props.getProperty("slice.artifactId");
                if (sliceInterface == null || sliceArtifactId == null) {
                    getLog().warn("Incomplete slice manifest in " + jarFile.getName() + " (" + entryName
                                  + "): missing slice.interface or slice.artifactId");
                    continue;
                }
                // Extract groupId from base.artifact (groupId:baseArtifactId)
                var baseArtifact = props.getProperty("base.artifact");
                String groupId;
                if (baseArtifact != null && baseArtifact.contains(":")) {
                    groupId = baseArtifact.split(":") [0];
                } else {
                    getLog().warn("Missing or invalid base.artifact in " + jarFile.getName() + " (" + entryName + ")");
                    continue;
                }
                // Value: groupId:artifactId:version
                var value = groupId + ":" + sliceArtifactId + ":" + version;
                mappings.setProperty(sliceInterface, value);
                getLog().debug("Found slice: " + sliceInterface + " -> " + value);
            }
        }
    }

    private void writeOutput(Properties mappings) throws MojoExecutionException {
        var parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        try (var writer = new FileWriter(outputFile)) {
            mappings.store(writer,
                           "Generated by jbct:collect-slice-deps\n# Key: API interface FQN\n# Value: groupId:artifactId:version");
            getLog().info("Wrote " + mappings.size() + " slice dependencies to " + outputFile);
        } catch (IOException e) {
            throw new MojoExecutionException("Failed to write slice dependencies", e);
        }
    }
}
