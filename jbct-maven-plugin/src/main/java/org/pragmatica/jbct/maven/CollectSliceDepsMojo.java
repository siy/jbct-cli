package org.pragmatica.jbct.maven;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.jar.JarFile;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

/**
 * Scans compile dependencies for slice manifests and writes interface-to-artifact mappings.
 * This allows the annotation processor to resolve slice dependency versions.
 *
 * <p>For each dependency JAR containing META-INF/slice-api.properties, extracts:
 * <ul>
 *   <li>api.interface - the slice API interface fully qualified name</li>
 *   <li>slice.artifact - the slice artifact coordinates (groupId:artifactId)</li>
 * </ul>
 *
 * <p>Writes mappings to slice-deps.properties in format:
 * <pre>
 * # Key: interface qualified name
 * # Value: groupId:artifactId:version
 * org.example.api.InventoryService=org.example:inventory:1.0.0
 * </pre>
 */
@Mojo(name = "collect-slice-deps",
 defaultPhase = LifecyclePhase.GENERATE_SOURCES,
 requiresDependencyResolution = ResolutionScope.COMPILE)
public class CollectSliceDepsMojo extends AbstractMojo {
    private static final String MANIFEST_PATH = "META-INF/slice-api.properties";

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;

    @Parameter(property = "jbct.outputFile",
    defaultValue = "${project.build.outputDirectory}/slice-deps.properties")
    private File outputFile;

    @Parameter(property = "jbct.skip", defaultValue = "false")
    private boolean skip;

    @Override
    public void execute() throws MojoExecutionException {
        if (skip) {
            getLog().info("Skipping slice dependency collection");
            return;
        }
        var mappings = new Properties();
        for (var artifact : project.getArtifacts()) {
            var file = artifact.getFile();
            if (file == null || !file.exists() || !file.getName()
                                                       .endsWith(".jar")) {
                continue;
            }
            try{
                extractSliceManifest(file, artifact.getVersion(), mappings);
            } catch (IOException e) {
                getLog().debug("Could not read JAR: " + file + " - " + e.getMessage());
            }
        }
        writeOutput(mappings);
    }

    private void extractSliceManifest(File jarFile, String version, Properties mappings) throws IOException {
        try (var jar = new JarFile(jarFile)) {
            var entry = jar.getEntry(MANIFEST_PATH);
            if (entry == null) {
                return;
            }
            var props = new Properties();
            try (var stream = jar.getInputStream(entry)) {
                props.load(stream);
            }
            var apiInterface = props.getProperty("api.interface");
            var implInterface = props.getProperty("impl.interface");
            var sliceArtifact = props.getProperty("slice.artifact");
            if (sliceArtifact == null) {
                getLog().warn("Incomplete slice manifest in " + jarFile.getName() + ": missing slice.artifact");
                return;
            }
            // Value: groupId:artifactId:version
            var value = sliceArtifact + ":" + version;
            // Map both API and impl interfaces to support both usage patterns
            if (apiInterface != null) {
                mappings.setProperty(apiInterface, value);
                getLog().debug("Found slice API: " + apiInterface + " -> " + value);
            }
            if (implInterface != null) {
                mappings.setProperty(implInterface, value);
                getLog().debug("Found slice impl: " + implInterface + " -> " + value);
            }
        }
    }

    private void writeOutput(Properties mappings) throws MojoExecutionException {
        var parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        try (var writer = new FileWriter(outputFile)) {
            mappings.store(writer,
                           "Generated by jbct:collect-slice-deps\n# Key: API interface FQN\n# Value: groupId:artifactId:version");
            getLog().info("Wrote " + mappings.size() + " slice dependencies to " + outputFile);
        } catch (IOException e) {
            throw new MojoExecutionException("Failed to write slice dependencies", e);
        }
    }
}
