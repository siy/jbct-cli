package org.pragmatica.jbct.maven;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.Set;

/**
 * Collects provided dependencies with specified classifiers and writes them to a properties file.
 * This allows the annotation processor to resolve slice dependency versions.
 */
@Mojo(name = "collect-slice-deps",
      defaultPhase = LifecyclePhase.GENERATE_SOURCES,
      requiresDependencyResolution = ResolutionScope.COMPILE)
public class CollectSliceDepsMojo extends AbstractMojo {

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;

    @Parameter(property = "jbct.outputFile",
               defaultValue = "${project.build.directory}/slice-deps.properties")
    private File outputFile;

    @Parameter(property = "jbct.includeClassifiers",
               defaultValue = "api")
    private String includeClassifiers;

    @Parameter(property = "jbct.skip", defaultValue = "false")
    private boolean skip;

    @Override
    public void execute() throws MojoExecutionException {
        if (skip) {
            getLog().info("Skipping slice dependency collection");
            return;
        }

        var props = new Properties();
        var classifiers = Set.of(includeClassifiers.split(","));

        for (var artifact : project.getArtifacts()) {
            if (!"provided".equals(artifact.getScope())) {
                continue;
            }

            var classifier = artifact.getClassifier();
            if (classifier == null || !classifiers.contains(classifier)) {
                continue;
            }

            // Key: groupId:artifactId:classifier (escaped for properties format)
            var key = escapeKey(artifact.getGroupId() + ":" +
                                artifact.getArtifactId() + ":" +
                                classifier);

            // Value: resolved version
            props.setProperty(key, artifact.getVersion());

            getLog().debug("Collected: " + key + "=" + artifact.getVersion());
        }

        // Ensure directory exists
        var parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }

        try (var writer = new FileWriter(outputFile)) {
            props.store(writer, "Generated by jbct:collect-slice-deps");
            getLog().info("Wrote " + props.size() + " dependencies to " + outputFile);
        } catch (IOException e) {
            throw new MojoExecutionException("Failed to write dependencies", e);
        }
    }

    private String escapeKey(String key) {
        // Escape : for properties file format
        return key.replace(":", "\\:");
    }
}
